<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github的.gitignore忽略文件</title>
      <link href="2022/08/22/github-ignore/"/>
      <url>2022/08/22/github-ignore/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天开学第一天，写了一个调api OCR公式转latex的代码，我自己的帐号密钥文件需要隐藏起来。我使用的是不把git里的这个密钥文件上传到github，下面记录一下方法。</p><p><strong>重要！重要！重要！重要的事情说三遍！大家一定要养成在项目开始就创建 .gitignore 文件的习惯，否则一旦push，处理起来会非常麻烦。</strong></p><h1 id="gitignore文件"><a href="#gitignore文件" class="headerlink" title=".gitignore文件"></a>.gitignore文件</h1><p>在git中如果想忽略掉某个文件，不让这个文件提交到版本库中，可以使用修改 .gitignore 文件的方法。    </p><h2 id="gitignore-文件创建"><a href="#gitignore-文件创建" class="headerlink" title=".gitignore 文件创建"></a>.gitignore 文件创建</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">touch  .gitignore     #创建gitignore隱藏文件  </span><br><span class="line">vim    .gitignore     #编辑文件，加入指定文件</span><br></pre></td></tr></table></figure><p>示例：这个文件每一行保存了一个匹配的规则<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 此为注释 – 将被 Git 忽略</span><br><span class="line">*.a       # 忽略所有 .a 结尾的文件</span><br><span class="line">!lib.a    # 但 lib.a 除外</span><br><span class="line">&#x2F;TODO     # 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir&#x2F;TODO</span><br><span class="line">build&#x2F;    # 忽略 build&#x2F; 目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt # 会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure></p><p>文件.gitignore的格式规范：  </p><pre><code>1. #为注释   2. 可以使用shell所使用的正则表达式来进行模式匹配   3. 匹配模式最后跟&quot;/&quot;说明要忽略的是目录 4. 使用！取反（例如目录中包含  test.a，并且gitignore文件中包含  *.[oa]，如果在文件中加入 ！test.a   表明忽略除test.a文件以外的后缀名为.a或者.o的文件）</code></pre><h1 id="如果已经push了怎么办"><a href="#如果已经push了怎么办" class="headerlink" title="如果已经push了怎么办"></a>如果已经push了怎么办</h1><p>有时候在项目开发过程中，想把某些目录或文件加入忽略规则，按照上述方法定义后发现并未生效，原因是.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态） </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm -r --cached 文件&#x2F;文件夹名字</span><br></pre></td></tr></table></figure><p>去掉已经托管的文件或者文件夹，然后提交即可。</p><h1 id="gitignoreglobal全局忽略文件"><a href="#gitignoreglobal全局忽略文件" class="headerlink" title="gitignoreglobal全局忽略文件"></a>gitignoreglobal全局忽略文件</h1><p>另外 git 提供了一个全局的 .gitignore 相当于以后每一个仓库里符合规则的都不提交，你可以在你的用户目录下创建 ~/.gitignoreglobal 文件，以同样的规则来划定哪些文件是不需要版本控制的。</p><p>需要执行 <code>git config --global core.excludesfile ~/.gitignoreglobal</code>来使得它生效。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黄金正弦算法</title>
      <link href="2022/08/21/golden-sinAlgo/"/>
      <url>2022/08/21/golden-sinAlgo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>黄金正弦算法(Gold-SA)是 Tanyildizi 等 于2017 年提出的一种新型元启发式优化算法，其灵感来源于正弦函数单位圆内扫描类似于待优化问题解的空间搜索，并通过黄金分割率缩小搜索空间以逼近算法最优解。与传统元启发式优化算法相比，Gold-SA 算法具有原理简单、设置参数少、寻优能力强等特点。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><p>与其他基于种群的优化算法一样，Gold-SA 算法也从随机生成的种群开始。Gold-SA 算法初始种群旨在通过随机生成每个维度的均匀分布来更好地扫描搜索空间。</p><script type="math/tex; mode=display">V_{i}=rand*(ub-lb)+lb\tag{1}</script><p>式中$V_{i}$是第$i$个个体的初始值$ub$,$lb$为搜索空间的上下限。  </p><h2 id="黄金分割系数"><a href="#黄金分割系数" class="headerlink" title="黄金分割系数"></a>黄金分割系数</h2><p>Gold-SA 算法在位置更新过程中引入黄金分割系数 $x_{1}$ 和 $x_{2}$使“搜索”和“开发”达到良好的平衡，这些系数缩小了搜索空间引领个体趋近最优值。</p><script type="math/tex; mode=display">x_{1}=a*(1-t)+b*t</script><script type="math/tex; mode=display">x_{2}=a*t+b*(1-t)</script><p>式中$a$、$b$为黄金分割比率搜索初始值,一般$a= -\pi$,$b=\pi$,$t$为黄金分比率。$t = (\sqrt{5}-1)/2$  </p><h2 id="位置更新"><a href="#位置更新" class="headerlink" title="位置更新"></a>位置更新</h2><p>随着迭代次数的增加，Gold-SA算法通过下式进行位置更新</p><script type="math/tex; mode=display">\mathrm{V}_{\mathrm{i}}^{\mathrm{t}+1}=\mathrm{V}_{\mathrm{i}}^{\mathrm{t}}|\sin (\mathrm{r} 1)|-\mathrm{r}_{2} \sin \left(\mathrm{r}_{1}\right)\left|\mathrm{x}_{1} \mathrm{D}_{\mathrm{i}}^{\mathrm{t}}-\mathrm{x}_{2} \mathrm{~V}_{\mathrm{i}}^{\mathrm{t}}\right|</script><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><ol><li><p>初始化参数，设置黄金正弦相关参数</p></li><li><p>计算适应度值</p></li><li><p>计算黄金分割率</p></li><li><p>根据位置更新公式，更新位置。</p></li><li><p>计算适应度值，并更新最优位置，记录最优位置。</p></li><li><p>判断是否达到迭代结束条件，如果达到则输出最后结果，否则重复1-6.</p></li></ol><h1 id="算法结果"><a href="#算法结果" class="headerlink" title="算法结果"></a>算法结果</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220821212225.png" alt="">  </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1] TANYILDIZI E，DEMIＲ G. Golden sine algorithm: a novel math inspired algorithm［J］. Advances in Electrical and Computer Engineering，2017，17(2): 71 －79.</p><p>[2] 周有荣,李娜,周发辉.黄金正弦算法在水文地质参数优化中的应用[J].人民珠江,2020,41(06):117-120+128.</p><p>[3] <a href="https://blog.csdn.net/u011835903/article/details/111699194">https://blog.csdn.net/u011835903/article/details/111699194</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>混沌映射</title>
      <link href="2022/08/16/chaotic-mapping/"/>
      <url>2022/08/16/chaotic-mapping/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在优化领域，混沌映射可以用于替代伪随机数生成器，生成 0 到 1 之间的混沌数。经过实验证明，利用混沌序列进行种群初始化、选择、交叉和变异等操作会影响算法的整个过程，而且常常能取得比伪随机数更好的效果。</p><h1 id="混沌映射特征"><a href="#混沌映射特征" class="headerlink" title="混沌映射特征"></a>混沌映射特征</h1><p>混沌映射被用于生成混沌序列，这是一种由简单的确定性系统产生的随机性序列。一般混沌序列具有以下主要特征：  </p><ol><li>非线性；</li><li>对初值的敏感依赖性；</li><li>遍历性；</li><li>随机性；</li><li>奇异吸引子（混沌吸引子）；</li><li>分数维持性；</li><li>整体稳定局部不稳定；</li><li>长期不可预测性；</li><li>轨道不稳定性及分叉；</li><li>普适性和Feigenbaum常数。  </li></ol><h1 id="常见分类"><a href="#常见分类" class="headerlink" title="常见分类"></a>常见分类</h1><ol><li>Logistic 映射，又称虫口映射  <script type="math/tex; mode=display">z_{k+1}=\mu z_{k}\left(1-z_{k}\right)</script> 其中，$z_{0} \notin\{0,0.25,0.5,0.75,1.0\} \quad \mu \in[0,4]$</li></ol><ol><li>PWLCM映射  <script type="math/tex; mode=display">z_{k+1}=\left\{\begin{array}{ll}z_{k} / p, & z_{k} \in(0, p) \\ \left(1-z_{k}\right)(1-p), & z_{k} \in[p, 1)\end{array} ;\right.</script></li></ol><ol><li>Singer映射   <script type="math/tex; mode=display">z_{k+1}=\mu\left(7.86 z_{k}-23.31 z_{k}^{2}+28.75 z_{k}^{3}-13.302875 z_{k}^{4}\right)</script> 其中，当 $\mu \in[0.9,1.08]$ 时，Singer 映射具有混沌行为。</li></ol><ol><li><p>Sine 映射  </p><script type="math/tex; mode=display">z_{k+1}=\frac{4}{a} \sin \left(\pi z_{k}\right)</script><p> Sine 映射是一种单峰映射，并且值域为 $[-1, 1]$, 其中 $a \in (0,4]$</p></li><li><p>Gussian映射  </p><script type="math/tex; mode=display">z_{k+1}=\left\{\begin{array}{ll}0, & z_{k}=0 \\ \bmod \left(\mu / z_{k}, 1\right), & z_{k} \neq 0\end{array} ;\right.</script></li><li><p>Tent 映射，又称帐篷映射</p><script type="math/tex; mode=display">z_{k+1}=\left\{\begin{array}{ll}z_{k}/(1-\lambda), & z_{k} \in (0, 1-\lambda] \\ (z_{k}-1+\lambda)/\lambda, & z_{k} \in (1-\lambda, 0]\end{array} ;\right.</script></li><li><p>Chebyshev 映射</p><script type="math/tex; mode=display">z_{k+1}=\cos(\phi \cos^{-1}z_{k})</script><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/BaobMa/p/15960929.html">https://www.cnblogs.com/BaobMa/p/15960929.html</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>鲸鱼算法</title>
      <link href="2022/08/14/whale-algo/"/>
      <url>2022/08/14/whale-algo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>鲸鱼算法（Whale Optimization Algorithm）是根据鲸鱼围捕猎物的行为而提出的算法。鲸鱼是一种群居的哺乳动物，在捕猎时它们也会相互合作对猎物进行驱赶和围捕。<br>鲸鱼算法中，每个鲸鱼的位置代表了一个可行解。在鲸鱼群捕猎过程中，每只鲸鱼有两种行为，一种是包围猎物，所有的鲸鱼都向着其他鲸鱼前进；另一种是汽包网，鲸鱼环形游动喷出气泡来驱赶猎物。在每一代的游动中，鲸鱼们会随机选择这两种行为来进行捕猎。在鲸鱼进行包围猎物的行为中，鲸鱼将会随机选择是向着最优位置的鲸鱼游去还是随机选择一只鲸鱼作为自己的目标，并向其靠近。</p><h1 id="算法原理"><a href="#算法原理" class="headerlink" title="算法原理"></a>算法原理</h1><p>在海洋活动中，座头鲸有着一种特殊的狩猎方法，这种觅食行为称为bubble-net 捕食策略，其狩猎行为如图所示。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815102849.png" alt=""></p><h2 id="包围猎物"><a href="#包围猎物" class="headerlink" title="包围猎物"></a>包围猎物</h2><p>座头鲸在狩猎时要包围猎物，为了描述这种行为，Mirjalili 提出了下面的数学模型：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815104759.png" alt=""><br>式中：$t$ 是当前迭代次数；$A$ 和 $C$ 为表示系数，$X^{*}(t)$ 表示目前为止最好的鲸鱼位置向量，$X(t)$ 表示当前鲸鱼的位置向量，$A$ 和 $C$ 由下式可得到<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815105230.png" alt=""><br>其中，$r_{1}$和$r_{2}$是(0,1)中的随机数，$a$ 的值从 2到 0 线性下降，$t$  表示当前的迭代次数，$T_{max}$ 为最大迭代次数。</p><h2 id="狩猎行为"><a href="#狩猎行为" class="headerlink" title="狩猎行为"></a>狩猎行为</h2><p>根据座头鲸的狩猎行为，它是以螺旋运动游向猎物，故狩猎行为的数学模型如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815111640.png" alt=""><br>其中, $D_{p} = |X^{<em>}(t)−X(t)|$ 表示鲸鱼和猎物之间的距离，$X^{</em>}(t)$ 表示目前为止最好的位置向量，$b$ 是一个常数，用来定义螺线的形状， $l$ 是 $(−1,1)$ 中的随机数。值得注意的是，鲸鱼以螺旋形状游向猎物的同时还要收缩包围圈。因此，在这种同步行为模型中，假设有 $P_{i}$ 的概率选择收缩包围机制和 $1−P_{i}$ 的概率选择螺旋模型来更新鲸鱼的位置，其数学模型如下:<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815112050.png" alt=""><br>攻击猎物时，在数学模型上靠近猎物设定了减小 $a$ 的值，这样 $A$ 的波动范围也随$a$ 下降。在迭代过程中当$a$的值从2到0下降时，$A$ 是在$[−a,a]$内的随机值，当 $A$ 的值在[−1,1]内时，鲸鱼的下一个位置可以是它现在的位置和猎物的位置之间的任意位置，算法设定当 $A&lt;1$ 时，鲸鱼向猎物发起攻击。</p><h2 id="搜索猎物"><a href="#搜索猎物" class="headerlink" title="搜索猎物"></a>搜索猎物</h2><p>在搜索猎物时，其数学模型如下：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220815112309.png" alt=""><br>其中，$X_{rand}$是随机选择的鲸鱼位置向量，算法设定当 $A≥1$ 时，随机选择一个搜索代理，根据随机选择的鲸鱼位置来更新其他鲸鱼的位置，迫使鲸鱼偏离猎物，借此找到一个更合适的猎物，这样可以加强算法的勘探能力使 WOA 算法能够进行全局搜索.</p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><p>（1）初始化参数：即鲸鱼种群规模大小 $SN$，最大迭代次数 $T_{max}$;<br>（2）算法初始化鲸鱼种群的位置；<br>（3）计算每一头鲸鱼相应的适应度值，根据适应度值的大小排序，并选取 $SN$ 个作为初始种群；<br>（4）计算出 $SN$ 个个体适应度值的大小，找出适应度值最小的个体位置作为最优位置；<br>（5）更新下一代的位置；<br>（6）若达到终止条件，则输出最优个体，即算法找到的最优解；否则，返回步骤（4）。  </p><h1 id="matlab代码"><a href="#matlab代码" class="headerlink" title="matlab代码"></a>matlab代码</h1><p><a href="https://github.com/callmeLP/Optimization-Algorithm/tree/main/WOA">https://github.com/callmeLP/Optimization-Algorithm/tree/main/WOA</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>Seyedali Mirjalili,Andrew Lewis. The Whale Optimization Algorithm[J]. Advances in Engineering Software,2016,95.<br><a href="https://www.jianshu.com/p/916a1dcac282">https://www.jianshu.com/p/916a1dcac282</a><br><a href="https://blog.csdn.net/u011835903/article/details/107559167">https://blog.csdn.net/u011835903/article/details/107559167</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>差分进化算法</title>
      <link href="2022/08/12/Differential-Evolution/"/>
      <url>2022/08/12/Differential-Evolution/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>差分进化算法(Differential Evolution Algorithm，DE)是一种高效的全局优化算法。它也是基于群体的启发式搜索算法，群中的每个个体对应一个解向量。差分进化算法的进化流程则与遗传算法非常类似，都包括变异、杂交和选择操作，但这些操作的具体定义与遗传算法有所不同。</p><h1 id="差分进化算法"><a href="#差分进化算法" class="headerlink" title="差分进化算法"></a>差分进化算法</h1><p>差分进化算法和遗传算法有些相似，但是比遗传算法简单好实现，但是差分进化算法的变种，或者说变形有很多，大家可以根据具体情况选择。<br>差分进化算法也是在现有的解上面，根据一定的办法选择几个解，根据变异公式把这几个解融合成一个变异解，这个过程称为变异；把第i个变异解和第i个旧解的每个参数，跟据一定概率选择选择新解或者旧解的值，称为交叉，形成交叉解；把第i个交叉解和第i个旧解比较，选择较优的解保存作为下一次循环的解，这也是差分进化算法最不同于遗传算法的地方。</p><h2 id="差分进化算法流程"><a href="#差分进化算法流程" class="headerlink" title="差分进化算法流程"></a>差分进化算法流程</h2><ol><li>初始化<br>随机初始化数目为NP的D维参数向量 $x$ ，$x(i)$ 表示第i个解，每个解参数可以表示为 $x(i,j)$ ，$i=1,2,…,NP,j=1,2,…,D$<br>解数目NP根据情况选择，一般选取[50,200]。</li><li><p>变异<br>对于每个解向量$x(i)$，对应的变异向量$v$可以表示为：</p><script type="math/tex; mode=display">\begin{aligned}v(i)=x(r_{0})+F*(x(r_{1})-x(r_{2}))\end{aligned}</script><p>$r0,r1,r2$为属于[1,…,NP]的三个随机数，并且 $i,r0,r1,r2$ 都不相同，这要求NP必须大于等于4。<br>变异算子 $F$ 取值范围为[0,2]，F过小可能陷入局部最优，F过大则不容易收敛，一般去[0.4,1]居多。<br>边界问题：如果变异以后的值$v(i,j)$超出了边界，可以随机再选择一个数，或者直接去边界值都是可以的。 </p></li><li><p>交叉<br>接下来求交叉向量u，对于u的每个值，有：<br>如果 $rand()&lt;=CR: u(i,j)=v(i,j)$<br>如果 $rand()&gt;CR : u(i,j)=x(i,j)$<br>$rand()$是一个随机数，CR是交叉算子，[0,1]，用来控制选择变异向量值还是原来的向量值。  </p></li><li>选择<br>把交叉向量和原向量对比，选择较优的那个，这里交叉向量之和对应的原向量对比，也就是对比$u(i)$和$x(i)$哪个更优，就选择哪个作为新的解向量，更新向量$x$，进行下一步。  </li><li>终止条件<br>当最后的解满足条件，或者遍历次数达到最大，则结束，否则重复2到4。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>差分进化算法比较简答，容易实现，可修改的地方也不少，比如变异向量选择上面，可以选择x(best)+F<em>(x(r1)-x(r2))，x(best)是全局最优解。甚至说F</em>(…)里面的随机参数，可以是四个六个，这些都是差分进化算法的变形。</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>题目：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/1.png" alt=""><br><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">作者:LP</span></span><br><span class="line"><span class="string">时间:2022年4月24日</span></span><br><span class="line"><span class="string">题目：差分进化算法</span></span><br><span class="line"><span class="string">参考:https://blog.csdn.net/Goldboys/article/details/112913122</span></span><br><span class="line"><span class="string">题目:f ( x , y ) = 3 c o s ( x y ) + x + y </span></span><br><span class="line"><span class="string">        x属于[-4, 4] </span></span><br><span class="line"><span class="string">        y属于[-4, 4] </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">参考使用面向过程思想编写 本人使用面向对象思想实现</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func_fitness</span>(<span class="params">x</span>):</span></span><br><span class="line">    value = <span class="number">3</span>*np.cos(x[<span class="number">0</span>] * x[<span class="number">1</span>] + x[<span class="number">0</span>] + x[<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DE</span>:</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化种群</span></span><br><span class="line"><span class="string">    参数: time 迭代次数</span></span><br><span class="line"><span class="string">          F    变异算子</span></span><br><span class="line"><span class="string">          CR   交叉算子</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, time, F, CR</span>):</span></span><br><span class="line">        self.X = <span class="number">0</span>      <span class="comment"># 最终迭代后的最优变量x</span></span><br><span class="line">        self.Y = <span class="number">0</span>      <span class="comment"># 最终迭代后的最优变量y</span></span><br><span class="line">        self.time = time</span><br><span class="line">        self.F = F</span><br><span class="line">        self.CR = CR</span><br><span class="line">        self.Ob=[]  <span class="comment">#种群列表中的适应度</span></span><br><span class="line">        self.trace = []  <span class="comment">#最小适应度</span></span><br><span class="line">        self.x = np.zeros((<span class="number">2</span>,<span class="number">50</span>))</span><br><span class="line">        self.v = np.zeros((<span class="number">2</span>,<span class="number">50</span>))   <span class="comment">#变异种群</span></span><br><span class="line">        self.u = np.zeros((<span class="number">2</span>,<span class="number">50</span>))   <span class="comment">#选择种群</span></span><br><span class="line">        self.x = np.random.rand(<span class="number">2</span>, <span class="number">50</span>) * <span class="number">8</span> - <span class="number">4</span>  <span class="comment">#将随机取值限制在区间范围内</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">            self.Ob.append(func_fitness(self.x[:,[m]]))</span><br><span class="line">        self.trace.append(<span class="built_in">min</span>(self.Ob))</span><br><span class="line">        </span><br><span class="line">    </span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    变异操作：随机选择三个不相同的值使用差分公式</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">variation</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            r1=random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r1==m):</span><br><span class="line">                r1 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            r2 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r2 == m) <span class="keyword">and</span> (r2 == r1):</span><br><span class="line">                r2 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            r3 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">while</span> (r3 == m) <span class="keyword">and</span> (r3 == r2) <span class="keyword">and</span> (r3 == r1):</span><br><span class="line">                r3 = random.randint(<span class="number">0</span>, <span class="number">50</span>-<span class="number">1</span>)</span><br><span class="line">            <span class="comment">#差分</span></span><br><span class="line">            self.v[:,m] = self.x[:,r1]+self.F*(self.x[:,r2]-self.x[:,r3])</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    交叉操作：概率小于CR值时，将变异种群的行向量赋给选择种群，否则使用初始化的种群</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span> </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">cross</span>(<span class="params">self</span>):</span></span><br><span class="line">        r=np.random.randint(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">2</span>):</span><br><span class="line">            cr=np.random.rand()</span><br><span class="line">            <span class="keyword">if</span> (cr &lt;= self.CR <span class="keyword">and</span> n == r):</span><br><span class="line">                self.u[n, :] = self.v[n, :]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.u[n, :] = self.x[n, :]</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    边界条件处理:交叉操作后，将选择种群中的值限制在取值范围内</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_bound</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> n <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">2</span>):</span><br><span class="line">            <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="number">50</span>):</span><br><span class="line">                <span class="keyword">if</span> self.u[n,m] &lt; -<span class="number">4</span>:</span><br><span class="line">                    self.u[n,m] = -<span class="number">4</span></span><br><span class="line">                <span class="keyword">if</span> self.u[n,m] &gt; <span class="number">4</span>:</span><br><span class="line">                    self.u[n,m] = <span class="number">4</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    获得索引</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_index</span>(<span class="params">self, Ob, sort_Ob</span>):</span></span><br><span class="line">        sort_Ob_index=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(Ob)):</span><br><span class="line">            qt=Ob.index(sort_Ob[i])</span><br><span class="line">            sort_Ob_index.append(qt)</span><br><span class="line">        <span class="keyword">return</span>  sort_Ob_index</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    选择操作:对选择矩阵排序</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">select</span>(<span class="params">self</span>):</span></span><br><span class="line">        Ob1=[]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            Ob1.append(func_fitness(self.u[:,m]))</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            <span class="keyword">if</span> Ob1[m] &lt; self.Ob[m]:</span><br><span class="line">                self.x[:,m] = self.u[:,m]</span><br><span class="line">        <span class="keyword">for</span> m <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">50</span>):</span><br><span class="line">            self.Ob[m] = func_fitness(self.x[:,m])</span><br><span class="line">        self.trace.append(<span class="built_in">min</span>(self.Ob))</span><br><span class="line">        sort_Ob = <span class="built_in">sorted</span>(self.Ob)</span><br><span class="line">        sort_Ob_index = self.get_index(self.Ob,sort_Ob)</span><br><span class="line">        self.x=self.x[:,sort_Ob_index]</span><br><span class="line">        self.X=self.x[:,<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># print(self.Ob)</span></span><br><span class="line">        self.Y=<span class="built_in">min</span>(self.Ob)</span><br><span class="line"></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    循环次数：主循环，按照循环次数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main_loop</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> time <span class="keyword">in</span> <span class="built_in">range</span>(self.time):</span><br><span class="line">            self.variation()</span><br><span class="line">            self.cross()</span><br><span class="line">            self.set_bound()</span><br><span class="line">            self.select()</span><br><span class="line">            <span class="built_in">print</span>(self.X, self.Y)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    cout = DE(<span class="number">100</span>, <span class="number">0.9</span>, <span class="number">0.5</span>)</span><br><span class="line">    cout.main_loop()</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>蛇优化算法</title>
      <link href="2022/08/09/snake-optimization/"/>
      <url>2022/08/09/snake-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>蛇优化(Snake Optimizer, SO)[1]是Hashim, F. A.和 Hussien, A. G两位教授于2022年提出的优化算法，其算法灵感来蛇的觅食和繁殖行为和模式。</p><h1 id="蛇优化算法"><a href="#蛇优化算法" class="headerlink" title="蛇优化算法"></a>蛇优化算法</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>雄性蛇和雌性蛇之间交配的发生受到某些因素的影响。蛇在春末和初夏交配，那时温度低。但交配过程不仅取决于温度，还取决于食物的充足性。如果<strong>温度低</strong>，<strong>食物充足</strong>;雄性蛇会互相争斗，以吸引雌性的注意力。雌性有权决定是否交配。如果发生交配，雌性开始在巢穴或洞穴中产卵，一旦卵出现，它就会离开。</p><h2 id="理论"><a href="#理论" class="headerlink" title="理论"></a>理论</h2><p>与所有元启发式算法一样，SO 首先生成均匀分布的随机种群，以便能够开始优化算法过程。初始化公式如下：</p><script type="math/tex; mode=display">X_{i}=X_{\min }+r \times\left(X_{\max }-X_{\min }\right)</script><p>其中，$X_{i}$ 为第i个位置的解,$r \in[0,1]$，$X_{max}$和$X_{min}$分别为待解决问题的上下界。此后，将初始化的种群分为雄性和雌性两个部分，原文中雄雌比例为1:1。</p><p>SO的探索和开发阶段主要受温度 $Temp$ 和食物量 $Q$ 的影响:</p><script type="math/tex; mode=display">T e m p=\exp (-t / T)</script><script type="math/tex; mode=display">Q=c_{1} * \exp (t-T / T)</script><p>其中 $t$ 代表当前迭代， $T$ 代表最大迭代次数，$c_{1} = 0.5$ </p><h3 id="探索阶段"><a href="#探索阶段" class="headerlink" title="探索阶段"></a>探索阶段</h3><p>当 $Q&lt;0.25$ （0.25为原文规定的阈值）SO通过择任何随机位置来搜索食物并更新它们相对于它的位置，即探索阶段，随机搜索公式为:</p><script type="math/tex; mode=display">  雄性：X_ {i}^ {m}  =  X_ {rand}^ {m}  (t)  \pm     c_ {2}    \times     A_ {m}    \times   ((  X_ {\max }  -  X_ {\min }  )  \times   rand+  X_ {\min }  )</script><script type="math/tex; mode=display">   雌性： X_{i}^{f}=X_{rand}^{f}(t)\pm c_{2}\times A_{f}\times ((X_{\max}-X_{\min})\times rand+X_{\min})</script><p>其中$X_ {i}^ {m}$和$X_ {i}^ {f}$是雄性和雌性SO位置，$X_{rand}^{m}(t)$和$X_{rand}^{f}(t)$是随机SO位置，$c_{2} = 0.05$, $r \in [0,1]$, $A_{m}$ 和 $A_{f}$ 为雄性和雌性SO寻找食物的能力，公式如下：</p><script type="math/tex; mode=display">雄性：A_{m}=exp(-f_{rand}^{m}/f_{i}^{m})</script><script type="math/tex; mode=display">雌性：A_{f}=exp(-f_{rand}^{f}/f_{i}^{f})</script><p>其中$f_{rand}^{m}$是$X_{rand}^{m}$的适应度,$f_{i}^{m}$是$X_{i}^{m}$的适应度，雌性同理。</p><h3 id="开发阶段"><a href="#开发阶段" class="headerlink" title="开发阶段"></a>开发阶段</h3><p>SO的开发阶段相对复杂，分为3种模式——靠近猎物(食物)模式、战斗模式、交配模式，3种模式同时受温度 $Temp$ 和食物量 $Q$ 的影响，这是与探索模式的不同之处。</p><h4 id="靠近猎物-食物-模式"><a href="#靠近猎物-食物-模式" class="headerlink" title="靠近猎物(食物)模式"></a>靠近猎物(食物)模式</h4><p>当 $Q&gt;0.25$ 且 $Temp&gt;0.6$，SO移动到食物上，其公式为：</p><script type="math/tex; mode=display">X_{i,j}(t+1)=X_{food}\pm c_{3}\times temp\times rand\times(X_{food}-X_{i,j}(t))</script><p>其中，$X_{i,j}$是整个SO的种群（雌雄），$X_{food}$为全局最优位置，$c_{3}=2$</p><h4 id="战斗-交配模式"><a href="#战斗-交配模式" class="headerlink" title="战斗/交配模式"></a>战斗/交配模式</h4><p>当 $Temp\leq0.6$ 时，蛇将处于战斗模式或交配模式。</p><ol><li><p>战斗模式</p><script type="math/tex; mode=display">     X_{i}^{m}(t+1)=X_{i}^{m}(t)\pm c_{3}\times FM\times rand\times(X_{best}^{f}-X_{i}^{m}(t))</script><script type="math/tex; mode=display">     X_{i}^{f}(t+1)=X_{i}^{f}(t)\pm c_{3}\times FF\times rand\times(X_{best}^{m}-X_{i}^{f}(t))</script><p> 其中 $X_{i}^{m}和X_{i}^{f}$ 为雄雌性SO位置，$FM和FF$ 为雄雌性战斗值， $X_{best}^{f}和X_{best}^{m}$ 为雌雄性SO最优位置。$FM和FF$分别表示为：</p><script type="math/tex; mode=display"> FM=exp(-f_{best}^{f}/f_{i})</script><script type="math/tex; mode=display"> FF=exp(-f_{best}^{m}/f_{i})</script><p> 其中$-f_{best}^{f}和-f_{best}^{m}$分别为最佳雌性和雄性SO适应度值，$f_{i}$为SO的代理位置。</p></li><li><p>交配模式</p><script type="math/tex; mode=display"> X_{i}^{m}(t+1)=X_{i}^{m}(t)\pm c_{3}\times M_{m}\times rand\times(Q\times X_{i}^{f}(t)-X_{i}^{m}(t))</script><script type="math/tex; mode=display"> X_{i}^{f}(t+1)=X_{i}^{f}(t)\pm c_{3}\times M_{f}\times rand\times(Q\times X_{i}^{m}(t)-X_{i}^{f}(t))</script><p> 其中 $X_{i}^{m}$ 和 $X_{i}^{f}$ 分别代表雌性和雄性的SO位置， $M_{m}$ 和 $M_{f}$ 分别代表雄性和雌性SO交配能力，表示如下：</p><script type="math/tex; mode=display"> M_{m}=exp(-f_{i}^{f}/f_{i}^{m})</script><script type="math/tex; mode=display"> M_{f}=exp(-f_{i}^{m}/f_{i}^{f})</script><p> 其中 $-f_{i}^{f}$ 和 $-f_{i}^{m}$ 分别表示SO的雌性和雄性搜索代理。如果有蛇蛋孵化的话（把最差的<strong>初始化</strong>，重开），则选择最差的雄性和雌性SO进行替换。</p></li></ol><h2 id="源代码"><a href="#源代码" class="headerlink" title="源代码"></a>源代码</h2><p>原文matlab链接：<a href="https://ww2.mathworks.cn/matlabcentral/fileexchange/106465-snake-optimizer">Snake Optimizer</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://zhuanlan.zhihu.com/p/468777899">https://zhuanlan.zhihu.com/p/468777899</a><br>Hashim, F. A., &amp; Hussien, A. G. (2022). Snake Optimizer: A novel meta-heuristic optimization algorithm.Knowledge-Based Systems, 108320.<a href="https://www.sciencedirect.com/science/article/pii/S0950705122001150">论文跳转</a></p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>粒子群优化算法</title>
      <link href="2022/08/09/Particle-Swarm-optimization/"/>
      <url>2022/08/09/Particle-Swarm-optimization/</url>
      
        <content type="html"><![CDATA[<h1 id="粒子群优化算法"><a href="#粒子群优化算法" class="headerlink" title="粒子群优化算法"></a>粒子群优化算法</h1><p>粒子群算法，也称粒子群优化算法或鸟群觅食算法（Particle Swarm Optimization），缩写为PSO，是由J. Kennedy和R. C. Eberhart等开发的一种新的进化算法(Evolutionary Algorithm -EA)[1]。PSO算法属于进化算法的一种，和模拟退火算法相似，它也是从随机解出发，通过迭代寻找最优解，它也是通过适应度来评价解的品质，但它比遗传算法规则更为简单，它没有遗传算法的“交叉”(Crossover)和“变异”(Mutation)操作，它通过追随当前搜索到的最优值来寻找全局最优。这种算法以其实现容易、精度高、收敛快等优点引起了学术界的重视，并且在解决实际问题中展示了其优越性。在 PSO 算法中，将鸟群中的个体称为“粒子”，可行域上的一个点代表食物源，即是个体(粒子)位置，也是所要优化问题的一个潜在解。在可行域中创建 N 个粒子，每个粒子的特征用位置、速度和适应度值表示。每个粒子在可行域中运动并计算得到适应度值，根据个体适应度最好值与群体适应度最好值更新个体位置，从而达到优化的目的[2]。该文首先介绍了标准粒子群算法的基本工作原理和算法迭代步骤，然后分别介绍了现今对粒子群算法的不同改进方法和算法在现实生活中的实际应用。在文章的结论中给出了粒子群算法下一步的研究方向。</p><h2 id="标准粒子群算法"><a href="#标准粒子群算法" class="headerlink" title="标准粒子群算法"></a>标准粒子群算法</h2><p>与其他的基于群体智能的算法相似，粒子群优化算法也是通过群体中不同粒子之间的相互合作和相互竞争来实现在寻优空间中的搜索过程以找到所求问题的最优位置。粒子群算法首先随机的初始化一群均匀分布在给定的寻优空间中的粒子(种群规模一般为30)，然后所有的粒子根据两个极值来更新自身的速度：一个是个体极值( $pbest$ )；另一个是群体极值($gbest$)。目前广泛使用的标准粒子群算法的数学描述为：设粒子群中粒子的总数为 popsize，粒子的维数为m，算法的终止条件(即最大迭代次数)为maxiter，第i个粒子在t时刻的飞行速度和在搜索空间中的位置分别为 $v_{i}(t)=[v_{i1}(t),v_{i2}(t),\cdots,v_{im}(t)]^T$, $x_{i}(t)=[x_{i1}(t),x_{i2}(t),\cdots,x_{im}(t)]^T$,粒子在t时刻的个体极值和群体极值分别为 $pbest_{i}(t)=[p_{i1}(t),p_{i2}(t),\cdots,p_{im}(t)]^T$, $gbest_{i}(t)=[g_{1},g_{2},\cdots,g_{m}]^T$ 所有的粒子按照如下的更新方式在搜索空间中飞行以找到最优解。  </p><script type="math/tex; mode=display">\begin{aligned}v_{i+1}(t+1)=wv_{i}(t)+c_{1}r_{1}(pbest_{i}(t)-x_{i}(t))+c_{2}r_{2}(gbest-x_{i}(t))     \end{aligned}</script><script type="math/tex; mode=display">\begin{aligned}x_{i+1}(t+1) = x_{i}(t)+v_{i+1}(t+1) \end{aligned}</script><p>其中，$ω$ 为惯性权重系数，决定了上次迭代速度保留的多少。它是粒子群算法的重要参数之一。在粒子群算法中，可以通过调节它的大小来平衡算法的全局搜索和局部搜索的能力。研究分析表明，在粒子群算法的算法初期，选择较大的惯性权重值可以使得算法有很强的全局搜索能力；而在粒子群算法的算法后期选择较小的惯性权重值可以使得粒子逐渐收敛到全局最优。因此，在很多改进的粒子群算法中，惯性权重采用了线性递减的方式进行更新。 $c1$ ， $c2$ 为算法的学习因子，它们分别影响着粒子的“自我学习”能力和“社会学习”能力。一般认为，设置较大的 $c1$ ，会使得所有粒子过多的在局部范围内徘徊，不利于算法的全局搜索；而设置较大的 $c2$ ，则会使得粒子过早的陷入局部极值，降低解的精度。 $r1$ 和 $r2$ 是介于[0,1]之间的随机数。标准粒子群算法的流程可以描述如下。<br>(1)设置种群规模、变量范围、惯性权重、学习因子等参数，并随机的初始化一群均匀分布在给定的寻优空间中的粒子(包含速度和位置信息)。<br>(2)计算群体中各个粒子的适应度值(即函数值)。设置第 $i$ 个粒子的适应度值为它的当前个体极值 $pbest_{i}$，所有粒子中的最好粒子设置为群体的全体极值 $gbest$。<br>(3)根据公式(1)、(2)更新每个粒子的速度和位置。<br>(4)对所有粒子，将其当前的函数值与它以前 找到过的最好位 置进行比较，如果当前位置较好，则将个体最优位置 $pbest_{i}$ 设置为这个粒子的位置，然后再对群体的全局极值 $gbest$ 更新。<br>(5)判断给定的终止条件是否满足。若满足终止条件，停止搜索，输出需要的结果；否则，返回(3)继续搜索。  </p><h1 id="应用研究"><a href="#应用研究" class="headerlink" title="应用研究"></a>应用研究</h1><p>从最初求解一些稍微简单的问题到更为复杂的问题，其发展趋势主要表现在：[3]<br>（1）PSO用于求解有约束的优化问题：2008年，刘伟等人基于参数方程利用粒子群算法求解含有等式约束的优化问题；2007年，曹春红等人利用粒子群算法求解几何约束问题；2008年，王金华等人利用粒子群算法求解约束离散优化问题；同年，魏静菅等基于模糊利用粒子群算法求解约束优化问题。<br>（2）PSO用于随机优化问题的求解：2006年，赵培忻等人利用粒子群算法求解随机装卸工问题；2007年，王芳等利用粒子群算法求解随机需求车辆路径问题；同年，李红梅等人研究了基于量子行为利用粒子群算法求解随机规划问题；陆琳，谭清美等人进行了利用粒子群算法求解随机需求VRP问题的研究。<br>（3）PSO用于最优控制问题的求解：孙凯等利用粒子群优化算法求解航天器太阳帆板伸展过程中，航天器姿态运动的最优控制问题；厉虹、张冰运用粒子群算法在线优化对模糊控制器的量化因子，获得平衡控制器参数的最优值；关圣涛等提出一种基于粒子群优化算法的非线性模型预测控制，在滚动优化部分应用粒子群优化算法求解预测控制律，对非线性系统施加优化控，实验效果良好；马昌喜等利用粒子群算法求解城市环路交通协调控制系统，效果良好。<br>（3）用于多目标优化：莫愿斌等利用粒子群算法求解多目标过程系统优化；贺益君等就补料分批生化反应器的动态多目标优化应用粒子群算法求解；张文明等针对水文模型的参数多目标优化应用粒子群算法求解；彭志平等针对协商僵局的多目标问题利用粒子群算法消解，其僵局解决能力明显比现有的其他方法强。<br>从以上的分析可以看出，从应用角度看粒子群算法应用于求解越来越复杂的问题，同时对粒子群算法的改进也越来越精细，优化性能也大大加强，但对算法优化性能的改进还没有结束，如何更精细、更简洁地改进算法，提高其性能，用于求解更多更复杂的问题，仍是一个研究的热点。[3]   </p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><p>[1]Fukuyama Y. Fundamentals of particle swarm techniques [A]. Lee K Y , El2Sharkawi M A. Modern Heuristic Optimization Techniques With Applications to Power Systems [M]. IEEE Power Engineering Society , 2002. 45～51<br>[2]陈子廓, 史宪睿. 基于觅食生境选择的改进粒子群算法[J]. 辽宁工业大学学报:自然科学版, 2022, 42(1):3.<br>[3]莫愿斌，刘贺同，陈德钊，粒子群优化算法的发展趋势 TP 183; TQ 015.9; 06-39:A，1001-4160(2009)04-430-434<br>[4]杨维, 李歧强. 粒子群优化算法综述[J]. 中国工程科学, 2004, 006(005):87-94.<br>[5]屈新怀, 单笛, 孟冠军. 基于靠近目标粒子群算法的AGV路径规划[J]. 合肥工业大学学报:自然科学版.<br>[6]Ali F A , Selvan K T . A study of PSO and its variants in respect of microstrip antenna feed point optimization[J]. IEEE, 2009:1817-1820.</p><hr><h1 id="python代码"><a href="#python代码" class="headerlink" title="python代码"></a>python代码</h1><p>题目：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/timu.png" alt=""></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">粒子群算法实现</span></span><br><span class="line"><span class="string">作者：LP</span></span><br><span class="line"><span class="string">时间：2022年4月13日</span></span><br><span class="line"><span class="string">参考：https://blog.csdn.net/qq_38048756/article/details/108945267</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fit_fun</span>(<span class="params">x</span>):</span>  <span class="comment"># 适应函数</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(<span class="number">100.0</span> * (x[<span class="number">0</span>][<span class="number">1</span>:] - x[<span class="number">0</span>][:-<span class="number">1</span>] ** <span class="number">2.0</span>) ** <span class="number">2.0</span> + (<span class="number">1</span> - x[<span class="number">0</span>][:-<span class="number">1</span>]) ** <span class="number">2.0</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Particle</span>:</span></span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, x_max, max_vel, dim</span>):</span></span><br><span class="line">        self.__pos = np.random.uniform(-x_max, x_max, (<span class="number">1</span>, dim))  <span class="comment"># 粒子的位置</span></span><br><span class="line">        self.__vel = np.random.uniform(-max_vel, max_vel, (<span class="number">1</span>, dim))  <span class="comment"># 粒子的速度</span></span><br><span class="line">        self.__bestPos = np.zeros((<span class="number">1</span>, dim))  <span class="comment"># 粒子最好的位置</span></span><br><span class="line">        self.__fitnessValue = fit_fun(self.__pos)  <span class="comment"># 适应度函数值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_pos</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__pos = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_pos</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__pos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_best_pos</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__bestPos = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_best_pos</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__bestPos</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_vel</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__vel = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_vel</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__vel</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_fitness_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__fitnessValue = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_fitness_value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__fitnessValue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PSO</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, size, iter_num, x_max, max_vel, tol, best_fitness_value=<span class="built_in">float</span>(<span class="params"><span class="string">&#x27;Inf&#x27;</span></span>), C1=<span class="number">2</span>, C2=<span class="number">2</span>, W=<span class="number">1</span></span>):</span></span><br><span class="line">        self.C1 = C1</span><br><span class="line">        self.C2 = C2</span><br><span class="line">        self.W = W</span><br><span class="line">        self.dim = dim  <span class="comment"># 粒子的维度</span></span><br><span class="line">        self.size = size  <span class="comment"># 粒子个数</span></span><br><span class="line">        self.iter_num = iter_num  <span class="comment"># 迭代次数</span></span><br><span class="line">        self.x_max = x_max</span><br><span class="line">        self.max_vel = max_vel  <span class="comment"># 粒子最大速度</span></span><br><span class="line">        self.tol = tol  <span class="comment"># 截至条件</span></span><br><span class="line">        self.best_fitness_value = best_fitness_value</span><br><span class="line">        self.best_position = np.zeros((<span class="number">1</span>, dim))  <span class="comment"># 种群最优位置</span></span><br><span class="line">        self.fitness_val_list = []  <span class="comment"># 每次迭代最优适应值</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 对种群进行初始化</span></span><br><span class="line">        self.Particle_list = [Particle(self.x_max, self.max_vel, self.dim) <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.size)]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_bestFitnessValue</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.best_fitness_value = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_bestFitnessValue</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.best_fitness_value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_bestPosition</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.best_position = value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_bestPosition</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.best_position</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新速度</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_vel</span>(<span class="params">self, part</span>):</span></span><br><span class="line">        vel_value = self.W * part.get_vel() + self.C1 * np.random.rand() * (part.get_best_pos() - part.get_pos()) + self.C2 * np.random.rand() * (self.get_bestPosition() - part.get_pos())</span><br><span class="line">        vel_value[vel_value &gt; self.max_vel] = self.max_vel</span><br><span class="line">        vel_value[vel_value &lt; -self.max_vel] = -self.max_vel</span><br><span class="line">        part.set_vel(vel_value)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 更新位置</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_pos</span>(<span class="params">self, part</span>):</span></span><br><span class="line">        pos_value = part.get_pos() + part.get_vel()</span><br><span class="line">        part.set_pos(pos_value)</span><br><span class="line">        value = fit_fun(part.get_pos())</span><br><span class="line">        <span class="keyword">if</span> value &lt; part.get_fitness_value():</span><br><span class="line">            part.set_fitness_value(value)</span><br><span class="line">            part.set_best_pos(pos_value)</span><br><span class="line">        <span class="keyword">if</span> value &lt; self.get_bestFitnessValue():</span><br><span class="line">            self.set_bestFitnessValue(value)</span><br><span class="line">            self.set_bestPosition(pos_value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update_ndim</span>(<span class="params">self</span>):</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.iter_num):</span><br><span class="line">            <span class="keyword">for</span> part <span class="keyword">in</span> self.Particle_list:</span><br><span class="line">                self.update_vel(part)  <span class="comment"># 更新速度</span></span><br><span class="line">                self.update_pos(part)  <span class="comment"># 更新位置</span></span><br><span class="line">            self.fitness_val_list.append(self.get_bestFitnessValue())  <span class="comment"># 每次迭代完把当前的最优适应度存到列表</span></span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;第&#123;&#125;次最佳适应值为&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(i, self.get_bestFitnessValue()))</span><br><span class="line">            <span class="keyword">if</span> self.get_bestFitnessValue() &lt; self.tol:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> self.fitness_val_list, self.get_bestPosition()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    pso = PSO(<span class="number">4</span>, <span class="number">5</span>, <span class="number">10000</span>, <span class="number">30</span>, <span class="number">60</span>, <span class="number">1e-4</span>, C1=<span class="number">2</span>, C2=<span class="number">2</span>, W=<span class="number">1</span>)</span><br><span class="line">    fit_var_list, best_pos = pso.update_ndim()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最优位置:&quot;</span> + <span class="built_in">str</span>(best_pos))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;最优解:&quot;</span> + <span class="built_in">str</span>(fit_var_list[-<span class="number">1</span>]))</span><br></pre></td></tr></table></figure><p>实验结果：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/res.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模拟退火算法 python实现</title>
      <link href="2022/08/08/Simulated-Annealing/"/>
      <url>2022/08/08/Simulated-Annealing/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><strong>模拟退火算法</strong>(Simulated Annealing，SA)最早的思想是由N. Metropolis 等人于1953年提出。1983 年,S. Kirkpatrick 等成功地将退火思想引入到组合优化领域。它是基于Monte-Carlo迭代求解策略的一种随机寻优算法，其出发点是基于物理中固体物质的退火过程与一般组合优化问题之间的相似性。 从某一较高初温出发，伴随温度参数的不断下降,结合概率突跳特性在求解空间中随机寻找目标函数的全局最优解，即在局部最优解能概率性地跳出并最终趋于全局最优。<br><strong>优点：</strong>  </p><ul><li>模拟退火算法是一种通用的优化算法，理论上算法具有概率的全局优化性能。</li><li>赋予搜索过程一种时变且最终趋于零的概率突跳性，从而可有效避免陷入局部极小并最终趋于全局最优的串行结构的优化算法。  </li></ul><p><strong>应用：</strong>  </p><ul><li>VLSI(超大规模集成电路)最优设计、图像处理、组合优化问题、生产调度、控制工程、机器学习、神经网络、信号处理等领域。</li></ul><h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><p>模拟退火算法包含两个部分即Metropolis算法和退火过程，分别对应内循环和外循环。外循环就是退火过程，将固体达到较高的温度（初始温度 T（0）），然后按照降温系数alpha使温度按照一定的比例下降，当达到终止温度Tf时，冷却结束，即退火过程结束。  </p><p>Metropolis算法是内循环，即在每次温度下，迭代L次，寻找在该温度下能量的最小值（即最优解）。  </p><p>下图中所示即为在一次温度下，跌代L次，固体能量发生的变化。在该温度下，整个迭代过程中温度不发生变化，能量发生变化，当前一个状态x(n)的能量大于后一个状态x(n+1)的能量时，状态x(n)的解没有状态x(n+1)的解好，所以接受状态x(n+1)。但是如果下一状态的能量比前一个状态的能量高时，该不该接受下一状态呢？在这里设置一个接受概率P,即如果下一状态的能量比前一个状态的能量高，则接受下一状态的概率为P,下面具体讲一下如何接受下一个状态。<br><img src="https://img-blog.csdnimg.cn/2020110414441182.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt=""><br>Metropolis算法就是如何在局部最优解的情况下让其跳出来（如图中B、C、E为局部最优），是退火的基础。1953年Metropolis提出重要性采样方法，即以概率来接受新状态，而不是使用完全确定的规则，称为Metropolis准则，计算量较低。</p><p>假设开始状态在A，多次迭代之后更新到B的局部最优解，这时发现更新到B时，能力比A要低，则说明接近最优解了，因此百分百转移，状态到达B后，发现下一步能量上升了，如果是梯度下降则是不允许继续向前的，而这里会以一定的概率跳出这个坑，这各概率和当前的状态、能量等都有关系。所以说这个概率的设计是很重要的，下面从数学方面进行解释。</p><p>假设前一个状态为x(n),系统根据某一指标（梯度下降，上节的能量），状态变为x(n+1),相应的，系统的能量由E(n)变为E(n+1),定义系统由x(n)变为x(n+1)的接受概率P为：<br><img src="https://img-blog.csdnimg.cn/20201103203924739.png#pic_center" alt=""></p><h1 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h1><h2 id="模拟退火的基本思想"><a href="#模拟退火的基本思想" class="headerlink" title="模拟退火的基本思想"></a>模拟退火的基本思想</h2><ol><li><p>初始化：初始温度T(充分大)，初始解状态S(是算法迭代的起点)，每个T值的迭代次数L</p></li><li><p>对k=1, …, L做第(3)至第6步：</p></li><li><p>产生新解S′</p></li><li><p>计算增量ΔT=C(S′)-C(S)，其中C(S)为目标函数,C(S)相当于能量</p></li><li><p>若ΔT&lt;0则接受S′作为新的当前解，否则以概率exp(-ΔT/T)接受S′作为新的当前解.</p></li><li><p>如果满足终止条件则输出当前解作为最优解，结束程序。</p></li><li><p>T逐渐减少，且T-&gt;0，然后转第2步。</p></li></ol><p><img src="https://img-blog.csdnimg.cn/2020110414475911.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="模拟退火算法新解的产生和接受可分为如下四个步骤"><a href="#模拟退火算法新解的产生和接受可分为如下四个步骤" class="headerlink" title="模拟退火算法新解的产生和接受可分为如下四个步骤"></a>模拟退火算法新解的产生和接受可分为如下四个步骤</h2><ol><li><p>第一步是由一个产生函数从当前解产生一个位于解空间的新解；为便于后续的计算和接受，减少算法耗时，通常选择由当前新解经过简单地变换即可产生新解的方法，如对构成新解的全部或部分元素进行置换、互换等，注意到产生新解的变换方法决定了当前新解的邻域结构，因而对冷却进度表的选取有一定的影响。  </p></li><li><p>第二步是计算与新解所对应的目标函数差。因为目标函数差仅由变换部分产生，所以目标函数差的计算最好按增量计算。事实表明，对大多数应用而言，这是计算目标函数差的最快方法。  </p></li><li><p>第三步是判断新解是否被接受,判断的依据是一个接受准则，最常用的接受准则是Metropolis准则: 若ΔT&lt;0则接受S′作为新的当前解S，否则以概率P接受S′作为新的当前解S。  </p></li><li><p>第四步是当新解被确定接受时，用新解代替当前解，这只需将当前解中对应于产生新解时的变换部分予以实现，同时修正目标函数值即可。此时，当前解实现了一次迭代。可在此基础上开始下一轮试验。而当新解被判定为舍弃时，则在原当前解的基础上继续下一轮试验。  </p></li></ol><h1 id="实例分析"><a href="#实例分析" class="headerlink" title="实例分析"></a>实例分析</h1><p><img src="https://img-blog.csdnimg.cn/20201104152404601.png#pic_center" alt=""></p><blockquote><p>在该实例中f(x)为目标函数，即为能量。然后设置控制参数t(温度）。求目标函数f(x)的最小值和最优状态（最小值情况下x1和x2的值）,即x1,x2在-5和5之间分别取何值时目标函数f(x)的值最小。在每次迭代中，x1,x2在-5到5之间取任意值。<br>首先设置初始温度为T0 =100,降温系数为alpha =0.99,终止温度为Tf =0.01,内循环迭代次数iter =100。<br>下面是完整代码：</p></blockquote><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"><span class="keyword">from</span> random <span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">x, y</span>):</span>                  <span class="comment">#函数优化问题</span></span><br><span class="line">    res= <span class="number">4</span>*x**<span class="number">2</span>-<span class="number">2.1</span>*x**<span class="number">4</span>+x**<span class="number">6</span>/<span class="number">3</span>+x*y-<span class="number">4</span>*y**<span class="number">2</span>+<span class="number">4</span>*y**<span class="number">4</span></span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"><span class="comment">#x为公式里的x1,y为公式里面的x2</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SA</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, func, <span class="built_in">iter</span>=<span class="number">100</span>, T0=<span class="number">100</span>, Tf=<span class="number">0.01</span>, alpha=<span class="number">0.99</span></span>):</span></span><br><span class="line">        self.func = func</span><br><span class="line">        self.<span class="built_in">iter</span> = <span class="built_in">iter</span>         <span class="comment">#内循环迭代次数,即为L =100</span></span><br><span class="line">        self.alpha = alpha       <span class="comment">#降温系数，alpha=0.99</span></span><br><span class="line">        self.T0 = T0             <span class="comment">#初始温度T0为100</span></span><br><span class="line">        self.Tf = Tf             <span class="comment">#温度终值Tf为0.01</span></span><br><span class="line">        self.T = T0              <span class="comment">#当前温度</span></span><br><span class="line">        self.x = [random() * <span class="number">11</span> -<span class="number">5</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">iter</span>)] <span class="comment">#随机生成100个x的值</span></span><br><span class="line">        self.y = [random() * <span class="number">11</span> -<span class="number">5</span>  <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">iter</span>)] <span class="comment">#随机生成100个y的值</span></span><br><span class="line">        self.most_best =[]</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        random()这个函数取0到1之间的小数</span></span><br><span class="line"><span class="string">        如果你要取0-10之间的整数（包括0和10）就写成 (int)random()*11就可以了，11乘以零点多的数最大是10点多，最小是0点多</span></span><br><span class="line"><span class="string">        该实例中x1和x2的绝对值不超过5（包含整数5和-5），（random() * 11 -5）的结果是-6到6之间的任意值（不包括-6和6）</span></span><br><span class="line"><span class="string">        （random() * 10 -5）的结果是-5到5之间的任意值（不包括-5和5），所有先乘以11，取-6到6之间的值，产生新解过程中，用一个if条件语句把-5到5之间（包括整数5和-5）的筛选出来。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.history = &#123;<span class="string">&#x27;f&#x27;</span>: [], <span class="string">&#x27;T&#x27;</span>: []&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_new</span>(<span class="params">self, x, y</span>):</span>   <span class="comment">#扰动产生新解的过程</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            x_new = x + self.T * (random() - random())</span><br><span class="line">            y_new = y + self.T * (random() - random())</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">5</span> &lt;= x_new &lt;= <span class="number">5</span>) &amp; (-<span class="number">5</span> &lt;= y_new &lt;= <span class="number">5</span>):  </span><br><span class="line">                <span class="keyword">break</span>                                  <span class="comment">#重复得到新解，直到产生的新解满足约束条件</span></span><br><span class="line">        <span class="keyword">return</span> x_new, y_new </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">Metrospolis</span>(<span class="params">self, f, f_new</span>):</span>   <span class="comment">#Metropolis准则</span></span><br><span class="line">        <span class="keyword">if</span> f_new &lt;= f:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            p = math.exp((f - f_new) / self.T)</span><br><span class="line">            <span class="keyword">if</span> random() &lt; p:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">best</span>(<span class="params">self</span>):</span>    <span class="comment">#获取最优目标函数值</span></span><br><span class="line">        f_list = []    <span class="comment">#f_list数组保存每次迭代之后的值</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">iter</span>):</span><br><span class="line">            f = self.func(self.x[i], self.y[i])</span><br><span class="line">            f_list.append(f)</span><br><span class="line">        f_best = <span class="built_in">min</span>(f_list)</span><br><span class="line">        </span><br><span class="line">        idx = f_list.index(f_best)</span><br><span class="line">        <span class="keyword">return</span> f_best, idx    <span class="comment">#f_best,idx分别为在该温度下，迭代L次之后目标函数的最优解和最优解的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="comment">#外循环迭代，当前温度小于终止温度的阈值</span></span><br><span class="line">        <span class="keyword">while</span> self.T &gt; self.Tf:       </span><br><span class="line">           </span><br><span class="line">            <span class="comment">#内循环迭代100次</span></span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.<span class="built_in">iter</span>): </span><br><span class="line">                f = self.func(self.x[i], self.y[i])                    <span class="comment">#f为迭代一次后的值</span></span><br><span class="line">                x_new, y_new = self.generate_new(self.x[i], self.y[i]) <span class="comment">#产生新解</span></span><br><span class="line">                f_new = self.func(x_new, y_new)                        <span class="comment">#产生新值</span></span><br><span class="line">                <span class="keyword">if</span> self.Metrospolis(f, f_new):                         <span class="comment">#判断是否接受新值</span></span><br><span class="line">                    self.x[i] = x_new             <span class="comment">#如果接受新值，则把新值的x,y存入x数组和y数组</span></span><br><span class="line">                    self.y[i] = y_new</span><br><span class="line">            <span class="comment"># 迭代L次记录在该温度下最优解</span></span><br><span class="line">            ft, _ = self.best()</span><br><span class="line">            self.history[<span class="string">&#x27;f&#x27;</span>].append(ft)</span><br><span class="line">            self.history[<span class="string">&#x27;T&#x27;</span>].append(self.T)</span><br><span class="line">            <span class="comment">#温度按照一定的比例下降（冷却）</span></span><br><span class="line">            self.T = self.T * self.alpha        </span><br><span class="line">            count += <span class="number">1</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment"># 得到最优解</span></span><br><span class="line">        f_best, idx = self.best()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;F=<span class="subst">&#123;f_best&#125;</span>, x=<span class="subst">&#123;self.x[idx]&#125;</span>, y=<span class="subst">&#123;self.y[idx]&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">sa = SA(func)</span><br><span class="line">sa.run()</span><br><span class="line"></span><br><span class="line">plt.plot(sa.history[<span class="string">&#x27;T&#x27;</span>], sa.history[<span class="string">&#x27;f&#x27;</span>])</span><br><span class="line">plt.title(<span class="string">&#x27;SA&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;T&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;f&#x27;</span>)</span><br><span class="line">plt.gca().invert_xaxis()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>运行结果：<br><img src="https://img-blog.csdnimg.cn/2020111014271776.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80ODI0MTI5Mg==,size_16,color_FFFFFF,t_70#pic_center" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/weixin_48241292/article/details/109468947">https://blog.csdn.net/weixin_48241292/article/details/109468947</a><br><a href="https://arxiv.org/abs/quant-ph/0205020">Study of Optimization Problems by Quantum Annealing</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo butterfly主题添加备案信息</title>
      <link href="2022/03/30/hexo-add-ICP/"/>
      <url>2022/03/30/hexo-add-ICP/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天腾讯云的客服给我打电话让我在网站页脚添加备案信息<br>网上找了一个方法使用后hexo报错<br>链接如下：<br><a href="https://blog.csdn.net/qq_51604330/article/details/114530264">https://blog.csdn.net/qq_51604330/article/details/114530264</a><br>不过总归是让我找到了改的位置，下面介绍修改方法</p><h1 id="添加方法"><a href="#添加方法" class="headerlink" title="添加方法"></a>添加方法</h1><ol><li><p>按照路径找到footer.pug文件<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330223752.png" alt=""></p></li><li><p>打开文件并在图示位置添加一下内容</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.framework-info</span><br><span class="line">  img(src &#x3D; &#39;https:&#x2F;&#x2F;static.dy208.cn&#x2F;o_1dfilp8ruo521thr1hvf18ji17soa.png&#39;)</span><br><span class="line">  span&#x3D; &#39; &#39;</span><br><span class="line">  a(href&#x3D;&#39;https:&#x2F;&#x2F;beian.miit.gov.cn&#x2F;&#39;)&#x3D; &#39;黔ICP备2022002429号-1&#39;</span><br></pre></td></tr></table></figure><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330223954.png" alt=""></p></li></ol><h1 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220330224116.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>遗传算法python实现</title>
      <link href="2022/03/27/Genetic-Algorithm/"/>
      <url>2022/03/27/Genetic-Algorithm/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>上课学的基础遗传算法，我用python实现了一遍。<br>选择算法使用轮盘赌博<br>基因交叉每次一位<br>基因变异每次一位  </p><p>算法效果不是很好，有大佬熟悉的话感谢留言指导一下。<br><span id="more"></span></p><h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>求解函数的最大值y=xsin(10x)+xsin(2x),自变量取值：0—5<br>函数图像：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/1.png" alt="">  </p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">作者：LP</span></span><br><span class="line"><span class="string">时间：2022年3月24日</span></span><br><span class="line"><span class="string">介绍：遗传算法</span></span><br><span class="line"><span class="string">参考：https://blog.csdn.net/weixin_42053726/article/details/82722758</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">题目：y=xsin(10x)+xsin(2x),自变量取值：0-5</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_len</span>(<span class="params"><span class="built_in">len</span>, accu</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因长度计算</span></span><br><span class="line"><span class="string">    参数： len 区间长度(整型)</span></span><br><span class="line"><span class="string">         accu 精确度（精确到小数点后多少位）</span></span><br><span class="line"><span class="string">    返回值： 二进制长度</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    temp = <span class="built_in">len</span> * (<span class="number">10</span> ** accu)</span><br><span class="line">    <span class="comment"># print(temp)</span></span><br><span class="line">    i = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> temp &gt; <span class="number">2</span> :</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">        temp = temp / <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_decode</span>(<span class="params">arr,a,b,accu</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    将列表转换为十进制数并映射到区间上</span></span><br><span class="line"><span class="string">    参数： arr 基因列表</span></span><br><span class="line"><span class="string">           a 区间起始点</span></span><br><span class="line"><span class="string">           b 区间终点</span></span><br><span class="line"><span class="string">           accu 精确到小数点后多少位</span></span><br><span class="line"><span class="string">    返回值： 十进制数</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="comment">#二进制转十进制</span></span><br><span class="line">    i = <span class="number">0</span></span><br><span class="line">    temp = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> arr:</span><br><span class="line">        temp = j * (<span class="number">2</span> ** i) + temp</span><br><span class="line">        i = i + <span class="number">1</span></span><br><span class="line">    <span class="comment">#映射到区间上</span></span><br><span class="line">    res = a + (b-a)/(<span class="number">2</span>**<span class="built_in">len</span>(arr)-<span class="number">1</span>)*temp</span><br><span class="line">    res = <span class="built_in">round</span>(res, accu)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_init</span>(<span class="params">pop, <span class="built_in">len</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    初始化基因序列</span></span><br><span class="line"><span class="string">    参数：  pop 种群个数 </span></span><br><span class="line"><span class="string">            len 个体基因长度</span></span><br><span class="line"><span class="string">    返回值： 二维数组 长度为种群个数 每个元素为个体基因序列</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">return</span> np.random.randint(<span class="number">2</span>, size=(pop, <span class="built_in">len</span>))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">F</span>(<span class="params">x</span>):</span> <span class="keyword">return</span> np.sin(<span class="number">10</span>*x)*x + np.cos(<span class="number">2</span>*x)*x + <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fitness</span>(<span class="params">pop, func</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    获取每个个体的适应度</span></span><br><span class="line"><span class="string">    参数：  pop 种群二位数组</span></span><br><span class="line"><span class="string">            func 目标函数</span></span><br><span class="line"><span class="string">    返回值： 每个个体的适应度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    fit = []</span><br><span class="line">    prob = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pop:</span><br><span class="line">        fit.append(func(gene_decode(i,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>)))    <span class="comment">#每个基因的适应度</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fit)):</span><br><span class="line">        prob.append(fit[i]/<span class="built_in">sum</span>(fit))        <span class="comment">#每个基因被选中的概率 </span></span><br><span class="line">    <span class="comment"># print(fit)</span></span><br><span class="line">    <span class="comment"># print(prob)</span></span><br><span class="line">    <span class="comment"># print(sum(prob))</span></span><br><span class="line">    <span class="keyword">return</span> fit,prob</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">selec</span>(<span class="params">pop, prob</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    轮盘赌方法 根据概率选择个体 更新种群二维数组</span></span><br><span class="line"><span class="string">    参数：  pop 种群二位数组</span></span><br><span class="line"><span class="string">            prob 概率数组</span></span><br><span class="line"><span class="string">    返回值： 新的种群二维数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    rand_prob = np.random.random(<span class="built_in">len</span>(prob))</span><br><span class="line">    new_pop = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> rand_prob:</span><br><span class="line">        <span class="comment"># print(&quot;prob:&quot;+str(i))</span></span><br><span class="line">        <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(prob)):</span><br><span class="line">            <span class="built_in">sum</span> += prob[j]</span><br><span class="line">            <span class="comment"># print(&quot;dangqianprob:&quot;+str(sum))</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">sum</span> &lt; i:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">else</span> :</span><br><span class="line">                new_pop.append(<span class="built_in">list</span>(pop[j]))</span><br><span class="line">                <span class="comment"># print(new_pop)</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> new_pop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_cross</span>(<span class="params">pop, cross_rate</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因交叉（单点交叉） 根据概率选择交叉点</span></span><br><span class="line"><span class="string">    参数：pop 种群二维数组</span></span><br><span class="line"><span class="string">            cross_rate 基因交叉概率</span></span><br><span class="line"><span class="string">    返回值：新的种群二位数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> cross_rate &lt; np.random.random():</span><br><span class="line">        local = np.random.randint(<span class="built_in">len</span>(pop[<span class="number">0</span>]))    <span class="comment">#选择交叉点位</span></span><br><span class="line">        gene_one = np.random.randint(<span class="built_in">len</span>(pop))    <span class="comment">#选择交叉的第一个基因</span></span><br><span class="line">        gene_two = np.random.randint(<span class="built_in">len</span>(pop))    <span class="comment">#选择交叉的第二个基因</span></span><br><span class="line">        <span class="keyword">while</span> gene_one == gene_two:</span><br><span class="line">            gene_two = np.random.randint(<span class="built_in">len</span>(pop))</span><br><span class="line">        temp = pop[gene_one][local]</span><br><span class="line">        pop[gene_one][local] = pop[gene_two][local]</span><br><span class="line">        pop[gene_two][local] = temp</span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gene_change</span>(<span class="params">pop, change_rate</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    基因突变（单点突变） 根据概率选择突变点</span></span><br><span class="line"><span class="string">    参数： pop 种群二维数组</span></span><br><span class="line"><span class="string">            change_rate 基因突变概率</span></span><br><span class="line"><span class="string">    返回值：新的种群二位数组</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> change_rate &lt; np.random.random():</span><br><span class="line">        local = np.random.randint(<span class="built_in">len</span>(pop[<span class="number">0</span>]))  <span class="comment">#选择个体的基因位置</span></span><br><span class="line">        gene_choice = np.random.randint(<span class="built_in">len</span>(pop))   <span class="comment">#选择个体</span></span><br><span class="line">        pop[gene_choice][local] ^= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> pop</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    pop = gene_init(<span class="number">10</span>,<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>): </span><br><span class="line">        [fit, prob] = fitness(pop, F)</span><br><span class="line">        pop = selec(pop,prob)</span><br><span class="line">        pop = gene_cross(pop, <span class="number">0.8</span>)</span><br><span class="line">        pop = gene_change(pop, <span class="number">0.8</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> pop:</span><br><span class="line">        <span class="built_in">print</span>(gene_decode(i,<span class="number">0</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">    <span class="comment"># print(gene_decode([1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1],-1,2, 6))</span></span><br><span class="line">    <span class="comment"># print(gene_len(3,1))</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯云+Picgo搭建图床</title>
      <link href="2022/03/26/pic-bed/"/>
      <url>2022/03/26/pic-bed/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前用的遇见图床，很多图片链接资源被清除。辛辛苦苦写的博客啊，图床一挂什么图片都没了。图床还是自己建一个靠谱。<br>几天前折腾了一下七牛云，10G免费存储空间，看似不错。结果我的站点是https，免费的七牛云只提供http，导致上传了图片在浏览器里加载不出来。<br>果断选择付费的，现在每个平台的oss价格都不贵，我的服务器用的腾讯云，所以图床用腾讯云的COS，这样内网访问可以节省流量。<br>接下来介绍搭建方法。<br><span id="more"></span></p><h1 id="腾讯云cos"><a href="#腾讯云cos" class="headerlink" title="腾讯云cos"></a>腾讯云cos</h1><p>打开腾讯云注册帐号、实名认证、获取cos的免费存储…</p><h2 id="创建存储桶"><a href="#创建存储桶" class="headerlink" title="创建存储桶"></a>创建存储桶</h2><p>创建存储桶（存储同bucket可以理解为存东西的空间）：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327204518.png" alt=""><br>按照官方的说明配置就行了  </p><p>访问权限这里因为是博客图床，我选择公有读私有写，最后一行这里腾讯云会提供一个免费的https链接我们可以用这个链接访问到图传的图片（或者你用域名解析到这个链接也可以）<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327204851.png" alt=""></p><p>后面的看着选，不懂得可以读一下文档，写的很清楚。<br>这样一个图床就建好了。  </p><h2 id="picgo需要用的参数"><a href="#picgo需要用的参数" class="headerlink" title="picgo需要用的参数"></a>picgo需要用的参数</h2><p>picgo需要用的参数位置先展示给大家看一下：<br><code>空间名</code>和<code>区域</code>：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327205911.png" alt=""><br>点击进入下图中的<code>访问密钥</code>，然后新建密钥即可获得<code>APPID</code>、<code>SecretId</code>和<code>SecretKey</code><br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327210023.png" alt=""></p><h1 id="PicGo"><a href="#PicGo" class="headerlink" title="PicGo"></a>PicGo</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://github.com/Molunerfinn/PicGo/releases">PicGo下载链接</a></p><h2 id="配置参数"><a href="#配置参数" class="headerlink" title="配置参数"></a>配置参数</h2><p>进入图床设置-&gt;腾讯云cos，安装之前讲的位置填入相应的参数，选择设为默认图床然后确定：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327211030.png" alt=""></p><p>这样我们就能进入上传区快乐的传图片啦！<br>上传区支持url上床和剪贴板上传，上传后图片链接会自动复制到剪贴板。</p><h2 id="PicGo官方文档"><a href="#PicGo官方文档" class="headerlink" title="PicGo官方文档"></a>PicGo官方文档</h2><p>有什么不懂的可以去<a href="https://picgo.github.io/PicGo-Doc/zh/guide/#%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85">PicGo官方文档</a></p><h1 id="vscode-PicGo"><a href="#vscode-PicGo" class="headerlink" title="vscode + PicGo"></a>vscode + PicGo</h1><p>强烈建议大家使用vscode中的picgo插件，<code>ctrl</code>+<code>alt</code>+<code>u</code>直接剪贴板上传并在光标位置写入markdown链接，很舒服！！！<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327212400.png" alt=""><br>安装后按照上文中的参数配置就能用了</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>PicGo：<a href="https://picgo.github.io/PicGo-Doc/zh/guide/">https://picgo.github.io/PicGo-Doc/zh/guide/</a><br>vscode picgo插件：<a href="https://baijiahao.baidu.com/s?id=1657980156535147441&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1657980156535147441&amp;wfr=spider&amp;for=pc</a>  </p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> picBed </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>将hexo配置到个人服务器 nginx配置https</title>
      <link href="2022/03/26/hexoToMyServer/"/>
      <url>2022/03/26/hexoToMyServer/</url>
      
        <content type="html"><![CDATA[<p>hexo配置到github国内访问不用梯子上不去，一直想把博客放到自己的服务器上，这样baidu也可以收录。接下来介绍一下配置过程。<br><span id="more"></span>  </p><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><p>云服务器 ubuntu20.04<br>本地主机装好hexo（不会的可以看下我之前关于hexo的文章）  </p><h1 id="将hexo配置到个人服务器"><a href="#将hexo配置到个人服务器" class="headerlink" title="将hexo配置到个人服务器"></a>将hexo配置到个人服务器</h1><h2 id="安装git和nginx"><a href="#安装git和nginx" class="headerlink" title="安装git和nginx"></a>安装git和nginx</h2><p>以下操作建立在 <code>root</code> 权限之下，如权限不足请申请 <code>root</code> 权限或采用 <code>sudo</code> 关键字。<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt-get update</span><br><span class="line">apt-get install git nginx -y</span><br></pre></td></tr></table></figure><br>安装完成后新建一个文件路径来存放我们的git仓库并初始化仓库：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir /var/repo/</span><br><span class="line">cd /var/repo</span><br><span class="line">git init --bare &#123;自定义仓库名name&#125;.git</span><br></pre></td></tr></table></figure></p><h2 id="配置-Nginx-托管文件目录"><a href="#配置-Nginx-托管文件目录" class="headerlink" title="配置 Nginx 托管文件目录"></a>配置 Nginx 托管文件目录</h2><p>创建一个新的www目录（如果想使用默认的可以跳过这一小节）<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mkdir -p /var/www/hexo</span><br></pre></td></tr></table></figure><br>修改 Nginx 的 default 文件使得 root 指向刚刚创建的 /var/www/hexo目录：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /etc/nginx/sites-available/default</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 找到root字段并修改为：</span></span><br><span class="line">root /var/www/hexo</span><br></pre></td></tr></table></figure><br>重启nginx服务：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><br>配置完成。</p><blockquote><p>tips:可以自己随便写个网页放到这个目录，ip访问一下服务器看看配置成功没有。</p></blockquote><h2 id="Git勾子（hooks）"><a href="#Git勾子（hooks）" class="headerlink" title="Git勾子（hooks）"></a>Git勾子（hooks）</h2><p>我们的hexo文件传到服务器的git后，需要同步传到nginx的托管目录下。这样访问网站时才会有hexo的内容,这就需要使用git hooks。</p><p>执行下面的命令，在自动生成的<code>&#123;自定义仓库名name&#125;.git/hooks</code> 目录下创建一个新的钩子文件：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">vim /var/repo/&#123;自定义仓库名name&#125;.git/hooks/post-receive</span><br></pre></td></tr></table></figure></p><blockquote><p>tips:注意这是要新建一个文件，而不是用<code>post-update.sample</code>这个文件。我踩了粗心大意的坑    </p></blockquote><p>打开文件后，加入下面的代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line"></span><br><span class="line">git --work-tree&#x3D;&#x2F;var&#x2F;www&#x2F;hexo --git-dir&#x3D;&#x2F;var&#x2F;repo&#x2F;&#123;自定义仓库名name&#125;.git checkout -f</span><br></pre></td></tr></table></figure><br>将文件保存后，赋予该文件可执行权限:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x &#x2F;var&#x2F;repo&#x2F;&#123;自定义仓库名name&#125;.git&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure></p><h2 id="使用Git部署本地Hexo到远端"><a href="#使用Git部署本地Hexo到远端" class="headerlink" title="使用Git部署本地Hexo到远端"></a>使用Git部署本地Hexo到远端</h2><p>将服务器地址添加到受信任的站点，在本地任意目录从服务器上把hexo_static仓库克隆下来：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone root@&#123;云服务器IP&#125;:&#x2F;var&#x2F;repo&#x2F;ganahBlog.git</span><br></pre></td></tr></table></figure></p><blockquote><p>tips: 如果你在远端服务器创建了 Git 用户并设定为拥有者，请将 root 改成 git （git用户）。</p></blockquote><p>编辑本地hexo工作目录中的<code>_config.yml</code>,将<code>url</code>改成<code>https://&#123;云服务器IP或域名&#125;/</code></p><p>将 deploy 目标改为 {服务器用户名}@{服务IP}:/var/repo/{自定义仓库名name}.git：<br><img src="https://pic4.zhimg.com/80/v2-82fe5b073a41cc15a722fa9d2ca54b33_720w.jpg" alt=""></p><p>在个人博客站点目录下，打开 <code>Git bash</code> ,使用 <code>hexo clean &amp;&amp; hexo g -d</code> 部署</p><p>至此，可使用IP地址访问博客。<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327160102.png" alt=""></p><h1 id="nginx配置https"><a href="#nginx配置https" class="headerlink" title="nginx配置https"></a>nginx配置https</h1><h2 id="获取证书文件"><a href="#获取证书文件" class="headerlink" title="获取证书文件"></a>获取证书文件</h2><p>自己去域名商那里申请一个nginx的证书文件（或者自己openssl签发），一般是如下几个：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">callmelp.online.csr</span><br><span class="line">callmelp.online.key</span><br><span class="line">callmelp.online_bundle.crt</span><br><span class="line">callmelp.online_bundle.pem</span><br></pre></td></tr></table></figure><br>我们需要用的是.crt和.key文件</p><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>在域名商那边把域名解析到自己服务器的ip地址</p><h2 id="配置nginx"><a href="#配置nginx" class="headerlink" title="配置nginx"></a>配置nginx</h2><p>添加https站点：修改 <code>/etc/nginx/sites-enabled/default</code>站点的配置文件(记得自己先备份)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">   listen 443;</span><br><span class="line">   server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">   ssl on;</span><br><span class="line">   root &#x2F;var&#x2F;www&#x2F;www.domain.com; #网站主页路径。此路径仅供参考，具体请您按照实际目录操作。</span><br><span class="line">   index index.html index.htm;   </span><br><span class="line">   ssl_certificate  &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;1_www.domain.com_bundle.crt; #证书文件路径+名称</span><br><span class="line">   ssl_certificate_key &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;conf&#x2F;2_www.domain.com.key; #私钥文件路径+名称</span><br><span class="line">   ssl_session_timeout 5m;</span><br><span class="line">   ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4;</span><br><span class="line">   ssl_protocols TLSv1 TLSv1.1 TLSv1.2;</span><br><span class="line">   ssl_prefer_server_ciphers on;</span><br><span class="line">   location &#x2F; &#123;</span><br><span class="line">      index index.html index.htm;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">server &#123;</span><br><span class="line">   listen 80;</span><br><span class="line">   server_name www.domain.com; #填写绑定证书的域名</span><br><span class="line">   rewrite ^(.*)$ https:&#x2F;&#x2F;$host$1 permanent; #把http的域名请求转成https</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>将hexo个人博客部署到个人云服务器<a href="https://zhuanlan.zhihu.com/p/120743882">https://zhuanlan.zhihu.com/p/120743882</a><br>Ubuntu下nginx服务器开启https的方法<a href="https://cloud.tencent.com/developer/article/1456497">https://cloud.tencent.com/developer/article/1456497</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步编程与多线程的区别</title>
      <link href="2022/01/08/asynoioAndthreading/"/>
      <url>2022/01/08/asynoioAndthreading/</url>
      
        <content type="html"><![CDATA[<h1 id="异步编程与多线程的区别"><a href="#异步编程与多线程的区别" class="headerlink" title="异步编程与多线程的区别"></a>异步编程与多线程的区别</h1><p><strong>共同点</strong>:  </p><blockquote><p>异步和多线程两者都可以达到避免调用线程阻塞的目的，从而提高软件的可响应性          </p></blockquote><p><strong>不同点</strong>：</p><blockquote><ol><li>线程不是一个计算机硬件的功能，而是<strong>操作系统提供</strong>的一种逻辑功能，线程本质上是进程中一段并发运行的代码，所以线程需要操作系统<strong>投入CPU资源</strong>来运行和调度。   <blockquote><p>多线程的优点很明显，线程中的处理程序依然是顺序执行，符合普通人的思维习惯，所以编程简单。但是多线程的缺点也同样明显，线程的使用（滥用）会给系统带来上下文切换的<strong>额外负担</strong>。并且线程间的共享变量可能造成<strong>死锁</strong>的出现   </p></blockquote></li><li>异步操作无须额外的线程负担，并且使用回调的方式进行处理，在设计良好的情况下，处理函数可以不必使用共享变量（即使无法完全不用，最起码可以减少 共享变量的数量），减少了死锁的可能。<br>当然异步操作也并非完美无暇。编写异步操作的<strong>复杂程度较高</strong>，程序主要使用回调方式进行处理，与普通人的思维方式有些出入，而且难以调试。<blockquote><p>这里有一个疑问。异步操作没有创建新的线程，我们一定会想，比如有一个文件操作，大量数据从硬盘上读取，若使用单线程的同步操作自然要等待会很长时间，但是若使用异步操作的话，我们让数据读取异步进行，二线程在数据读取期间去干其他的事情，我们会想，这怎么行呢，异步没有创建其他的线程，一个线程去干其他的事情去了，那数据的读取异步执行是去由谁完成的呢？实际上，本质是这样的:<br>熟悉电脑硬件的朋友肯定对<strong>DMA</strong>这个词不陌生，硬盘、光驱的技术规格中都有明确DMA的模式指标，其实网卡、声卡、显卡也是有DMA功能的。<strong>DMA就是直接内存访问的意思</strong>，也就是说，拥有DMA功能的硬件在和内存进行数据交换的时候可以不消耗CPU资源。只要CPU在发起数据传输时发送一个指令，<strong>硬件就开始自己和内存交换数据</strong>，在传输完成之后硬件会触发一个中断来通知操作完成。这些无须消耗CPU时间的I/O操作正是异步操作的硬件基础。所以即使在DOS 这样的单进程（而且无线程概念）系统中也同样可以发起异步的DMA操作。即CPU在数据的长时间读取过程中 ，只需要做两件事，第一发布指令，开始数据交换；第二，交换结束，得到指令，CPU再进行后续操作。而中间读取数据漫长的等待过程，<strong>CPU本身就不需要参与</strong>，顺序执行就是我不参与但是我要干等着，效率低下；异步执行就是，我不需要参与那我就去干其他事情去了，你做完了再通知我就可以了（回调）。<br>但是你想一下，如果有一些异步操作必须要CPU的参与才能完成呢，即我开始的那个线程是走不开的，这该怎么办呢，在python中这是系统自己去安排的，无需人工干预，这就比自己创建很多的线程更加高效。</p></blockquote></li></ol></blockquote><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ol><li>“多线程”，第一、最大的问题在于线程本身的调度和运行<strong>需要很多时间</strong>，因此<strong>不建议自己创建太大量的线程</strong>；第二、<strong>共享资源的调度比较难</strong>，涉及到死锁，上锁等相关的概念。  </li><li>“异步” ，异步最大的问题在于“回调”，这增加了软件设计上的难度。</li></ol><p>在实际设计时，我们可以将两者结合起来：</p><ol><li>当需要执行<strong>I/O操作</strong>时，使用<strong>异步操作</strong>比使用线程+同步I/O操作更合适。I/O操作不仅包括了直接的文件、网络的读写，还包括数据库操作、Web Service、HttpRequest以及.net Remoting等跨进程的调用。异步特别适用于大多数IO密集型的应用程序。</li><li>而线程的适用范围则是那种需要<strong>长时间CPU运算的场合</strong>，例如耗时较长的图形处理和算法执行。但是往 往由于使用线程编程的简单和符合习惯，所以很多朋友往往会使用线程来执行耗时较长的I/O操作。这样在只有少数几个并发操作的时候还无伤大雅，如果需要处理大量的并发操作时就不合适了。</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://www.cnblogs.com/yanan-boke/p/9395638.html">https://www.cnblogs.com/yanan-boke/p/9395638.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> threading </tag>
            
            <tag> asynoio </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache2配置ssl证书使用https，反向代理</title>
      <link href="2022/01/05/apache-ssl/"/>
      <url>2022/01/05/apache-ssl/</url>
      
        <content type="html"><![CDATA[<p>证书申请过程这里不介绍，apache证书文件包含以下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1_root_bundle.crt # 证书文件</span><br><span class="line">2_xxx.xxx.xxx.crt # 证书文件</span><br><span class="line">3_xxx.xxx.xxx.key # 私钥文件</span><br></pre></td></tr></table></figure></p><h1 id="配置证书"><a href="#配置证书" class="headerlink" title="配置证书"></a>配置证书</h1><p>在这里，我假设你已经会配置基本的<code>/etc/apache2/sites-available/000-default.conf</code>这个文件来达到已经可以通过 http 的方式来访问你的站点。    </p><p>编辑<code>/etc/apache2/sites-available/default-ssl.conf</code>添加如下配置：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSLEngine on</span><br><span class="line">ServerName www.domain.com</span><br><span class="line"></span><br><span class="line">SSLCertificateChainFile &#x2F;etc&#x2F;apache2&#x2F;ssl&#x2F;2_xxx.xxx.xxx.crt</span><br><span class="line">SSLCertificateKeyFile &#x2F;etc&#x2F;apache2&#x2F;ssl&#x2F;3_xxx.xxx.xxx.key</span><br><span class="line">SSLCertificateFile &#x2F;etc&#x2F;apache2&#x2F;ssl&#x2F;1_root_bundle.crt</span><br></pre></td></tr></table></figure></p><h1 id="http自动跳转至https"><a href="#http自动跳转至https" class="headerlink" title="http自动跳转至https"></a>http自动跳转至https</h1><p>在<code>/etc/apache2/sites-available/000-default.conf</code>中添加一下代码：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RewriteEngine on</span><br><span class="line">RewriteCond   %&#123;HTTPS&#125; !&#x3D;on</span><br><span class="line">RewriteRule   ^(.*)  https:&#x2F;&#x2F;%&#123;SERVER_NAME&#125;$1 [L,R]</span><br></pre></td></tr></table></figure></p><h1 id="使用https"><a href="#使用https" class="headerlink" title="使用https"></a>使用https</h1><p>终端中使能apache2的ssl模块：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2enmod ssl</span><br></pre></td></tr></table></figure><br>重启apache2：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service apache2 restart</span><br></pre></td></tr></table></figure><br>以上，网站即可通过https访问</p><hr><h1 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h1><p>若需要使用<code>域名/目录</code>这种方式访问即设置反向代理</p><p><strong>例如在我的网站中，使用www.domain.com/wss来代理服务器中65318端口中的ws服务</strong>：<br>在<code>000-default.conf</code>中添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">SSLProxyEngine on</span><br><span class="line">ProxyRequests Off</span><br><span class="line">ProxyPass &#x2F;wss ws:&#x2F;&#x2F;127.0.0.1:65318</span><br><span class="line">ProxyPassReverse &#x2F;wss ws:&#x2F;&#x2F;127.0.0.1:65318</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache2 </tag>
            
            <tag> ssl </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>coturn服务器搭建及踩坑</title>
      <link href="2022/01/05/coturn-server/"/>
      <url>2022/01/05/coturn-server/</url>
      
        <content type="html"><![CDATA[<h1 id="安装coturn"><a href="#安装coturn" class="headerlink" title="安装coturn"></a>安装coturn</h1><p>安装之前，先确保使用以下命令将apt-get更新到最新：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><br>安装coturn：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install coturn</span><br></pre></td></tr></table></figure><br>请确保使用以下命令在安装软件包后停止该服务, 因为安装完成后它将自动启动：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl stop coturn</span><br></pre></td></tr></table></figure></p><h1 id="生成证书文件"><a href="#生成证书文件" class="headerlink" title="生成证书文件"></a>生成证书文件</h1><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo openssl req -x509 -newkey rsa:2048 -keyout /etc/turn_server_pkey.pem -out /etc/turn_server_cert.pem -days 99999 -nodes </span><br></pre></td></tr></table></figure><h1 id="备份并创建配置文件"><a href="#备份并创建配置文件" class="headerlink" title="备份并创建配置文件"></a>备份并创建配置文件</h1><p>安装好coturn后会在<code>/etc</code>目录下创建<code>turnserver.conf</code><br>首先备份：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> copy the original turnserver configuration file to a backup <span class="keyword">in</span> the same directory</span></span><br><span class="line">cp /etc/turnserver.conf /etc/turnserver.conf.original</span><br></pre></td></tr></table></figure><br>用编辑器编辑<code>turnserver.conf</code>:  </p><blockquote><p>tips:<strong>内网地址</strong>是使用<code>ifconfig</code>后显示的地址，<strong>外网地址</strong>云服务器公网地址<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">listening-device=eth0</span><br><span class="line">listening-port=3478</span><br><span class="line">tls-listening-port=5349   </span><br><span class="line">listening-ip=&lt;内网地址&gt;   </span><br><span class="line">external-ip=&lt;外网地址&gt;</span><br><span class="line">server-name=&lt;域名&gt;</span><br><span class="line">realm=&lt;域名&gt;</span><br><span class="line">lt-cred-mech                                                                                                   </span><br><span class="line">userdb=/var/lib/turn/turndb                                                                               </span><br><span class="line">cert=/etc/turn_server_cert.pem                                                                           </span><br><span class="line">pkey=/etc/turn_server_pkey.pem                                                                         </span><br><span class="line">no-stdout-log                                                                                                   </span><br><span class="line">log-file=/var/tmp/turnserver.log                                                                         </span><br><span class="line">pidfile=&quot;/var/run/turnserver.pid&quot; </span><br><span class="line">user=&lt;用户名&gt;:&lt;密码&gt;</span><br><span class="line">cli-password=qwerty</span><br></pre></td></tr></table></figure><br>编辑<code>/etc/default/coturn</code>文件(去掉下面这句前面的#)：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TURNSERVER_ENABLED&#x3D;1</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h1><p>云服务器端口打开：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">1-65535 UDP  </span><br><span class="line">3478 TCP</span><br></pre></td></tr></table></figure><br>重启coturn：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">service coturn restart</span><br></pre></td></tr></table></figure><br>这将启动服务器中的coturn服务。你可以使用以下命令检查服务的状态：<br><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">systemctl status coturn</span><br></pre></td></tr></table></figure><br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327195746.png" alt=""></p><blockquote><p><strong>这里我踩的坑</strong>：记得关掉软件防火墙（ufw）!!!!!!!!!!<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327200006.png" alt=""></p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>测试地址:<a href="https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/">https://webrtc.github.io/samples/src/content/peerconnection/trickle-ice/</a><br>看到 relay 类型的就说明成功了</p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> coturn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电容器件选型</title>
      <link href="2021/12/07/cChoice/"/>
      <url>2021/12/07/cChoice/</url>
      
        <content type="html"><![CDATA[<h1 id="电容参数描述"><a href="#电容参数描述" class="headerlink" title="电容参数描述"></a>电容参数描述</h1><div class="table-container"><table><thead><tr><th style="text-align:center">电容</th><th style="text-align:center">陶瓷</th><th style="text-align:center">容值</th><th style="text-align:center">电压</th><th style="text-align:center">类型</th><th style="text-align:center">封装</th></tr></thead><tbody><tr><td style="text-align:center">CAP</td><td style="text-align:center">CER</td><td style="text-align:center">0.1UF</td><td style="text-align:center">16V</td><td style="text-align:center">Y5V</td><td style="text-align:center">0402</td></tr><tr><td style="text-align:center">CAP</td><td style="text-align:center">TANT</td><td style="text-align:center">1UF</td><td style="text-align:center">10%</td><td style="text-align:center">10V</td><td style="text-align:center">1206</td></tr><tr><td style="text-align:center">CAP</td><td style="text-align:center">CER</td><td style="text-align:center">0.1UF</td><td style="text-align:center">16V</td><td style="text-align:center">Y5V</td><td style="text-align:center">0402</td></tr></tbody></table></div><h1 id="电容参数特性"><a href="#电容参数特性" class="headerlink" title="电容参数特性"></a>电容参数特性</h1><p>（1）容量和误差：实际电容量和标称电容量允许的最大偏差范围。在选型上注意精度等级，用字母表示：D——±0.5%，F——±1%，G——±2%，J——±5 % ，K——±10%，M——±20%。<br>（2）额定工作电压：电容器在电路中能够长期稳定、可靠工作，所承受的最大直流电压。<br>（3）绝缘电阻：表示漏电大小，一般绝缘电阻越大越好，漏电也小电解电容的绝缘电阻一般较小。<br>（4）正切角损耗：在电场的作用下，电容器在单位时间内发热而消耗的能量。<br>（5）温度系数：在一定温度范围内，温度每变化1℃，电容量的相对变化值。温度系数越小越好。<br>（6）频率特性:电容器的电参数随电场频率而变化的性质。在高频条件下工作的电容器，由于介电常数在高频时比低频时小，电容量也相应减小。损耗也随频率的升高而增加。<br>（7）等效串联电阻（ESR）：损耗较大产品的ESR较大；随着容量的增大，产品的ESR将变小；钽电容的ESR特别小。  </p><h1 id="电容分类"><a href="#电容分类" class="headerlink" title="电容分类"></a>电容分类</h1><ol><li>陶瓷介质类</li><li>电解类： 钽、铝电解液</li><li>其他类（有机薄膜、云母、云母纸、空气）</li></ol><h1 id="电容型号命名"><a href="#电容型号命名" class="headerlink" title="电容型号命名"></a>电容型号命名</h1><p>依据(GB2470 -81 ) ，国产电容的型号命名一般由四部分组成，依次分别代表名称、材料、分类和序号。</p><ul><li>第一部分：名称，用字母表示，电容器用C。</li><li>第二部分：材料，用字母表示。</li><li>第三部分：分类，一般用数字表示，个别用字母表示。</li><li>第四部分：序号，用数字表示</li></ul><p><img src="https://www.hualigs.cn/image/60bdb77a0c4f3.jpg" alt=""></p><h2 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h2><p><img src="https://www.hualigs.cn/image/60bdb8350b823.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HardWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>电阻器件选型</title>
      <link href="2021/12/07/rChoice/"/>
      <url>2021/12/07/rChoice/</url>
      
        <content type="html"><![CDATA[<h1 id="电阻器件选型"><a href="#电阻器件选型" class="headerlink" title="电阻器件选型"></a>电阻器件选型</h1><h1 id="电阻介绍"><a href="#电阻介绍" class="headerlink" title="电阻介绍"></a>电阻介绍</h1><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ul><li>薄膜电阻：碳膜电阻、合成碳膜电阻、尽速氧化膜电阻…</li><li>绕线电阻：通用绕线电阻、功率绕线电阻、高频线绕线电阻…</li><li>实心电阻: 无机合成实心碳质电阻和有机…</li><li>特种电阻：湿敏电阻、热敏电阻、压敏电阻、光敏电阻、磁敏电阻、力敏电阻、气敏电阻。</li></ul><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327200848.png" alt=""><br>常用为金属膜电阻（直插），金属玻璃铀电阻（贴片）</p><p>电阻描述示例：  </p><div class="table-container"><table><thead><tr><th style="text-align:center">电阻</th><th style="text-align:center">贴片</th><th style="text-align:center">阻值</th><th style="text-align:center">精度</th><th style="text-align:center">精度</th><th style="text-align:center">功率</th><th style="text-align:center">封装</th></tr></thead><tbody><tr><td style="text-align:center">RES</td><td style="text-align:center">SMD</td><td style="text-align:center">22K</td><td style="text-align:center">OHM</td><td style="text-align:center">1%</td><td style="text-align:center">1/16W</td><td style="text-align:center">0402</td></tr><tr><td style="text-align:center">RES</td><td style="text-align:center">SMD</td><td style="text-align:center">22K</td><td style="text-align:center">OHM</td><td style="text-align:center">1%</td><td style="text-align:center">1/16W</td><td style="text-align:center">0402</td></tr></tbody></table></div><h2 id="选型要点"><a href="#选型要点" class="headerlink" title="选型要点"></a>选型要点</h2><ul><li>电阻的<strong><em>阻值</em></strong>满足应用电路使用。</li><li>电阻的<strong><em>额定功率</em></strong>大于电阻在应用电路实际工作功率。一般按额定功率70%降额设计选用。</li><li>电阻在应用电路中<strong><em>实际工作电压</em></strong>小于最大工作电压。一般按最高工作电压的75%降额设计选用。</li><li>电阻的<strong><em>稳定性、工作频率、噪声</em></strong>等特性满足应用电路要求。</li></ul><h1 id="阻值的表示"><a href="#阻值的表示" class="headerlink" title="阻值的表示"></a>阻值的表示</h1><p>标称阻值的表示方法采用GB/T2471中的E24、E48、E96、E192系列。</p><ul><li>E24:三位数字表述。前两位表示有效数字，第三位表示0的个数。</li><li>E96:四位字符表述。前三位表示有效数字，第四位表示0的个数。</li><li>E96系列三位字符表示法：用三位字符表示阻值，前两位数字表示E96系列序号，第三位代表10的n次幂</li></ul><h1 id="功率"><a href="#功率" class="headerlink" title="功率"></a>功率</h1><p>大部分情况下如下表所示：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201001.png" alt=""></p><h1 id="电阻尺寸"><a href="#电阻尺寸" class="headerlink" title="电阻尺寸"></a>电阻尺寸</h1><p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201057.png" alt=""></p><h1 id="上拉电阻"><a href="#上拉电阻" class="headerlink" title="上拉电阻"></a>上拉电阻</h1><h2 id="需要上拉的情况"><a href="#需要上拉的情况" class="headerlink" title="需要上拉的情况"></a>需要上拉的情况</h2><ol><li>TTL电路驱动coms电路时。</li><li>oc门电路加上拉电阻。</li><li>为加大输出引脚的驱动能力，有的单片机管脚上也常使用上拉电阻。</li><li>不适用管教。</li><li>线传输中电阻的匹配，一直反射波干扰…</li></ol><h2 id="上拉电阻选择"><a href="#上拉电阻选择" class="headerlink" title="上拉电阻选择"></a>上拉电阻选择</h2><ol><li>从节约功耗考虑应当足够大；电阻大，电流小。</li><li>从足够的驱动电流考虑应当足够小；电阻小，电流大。</li><li>对于高速电路，过大的上拉电阻可能边沿变平缓。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HardWare </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用流程</title>
      <link href="2021/09/04/github-log/"/>
      <url>2021/09/04/github-log/</url>
      
        <content type="html"><![CDATA[<p>记录一下github每次使用中需要进行的操作：</p><h1 id="Github流程"><a href="#Github流程" class="headerlink" title="Github流程"></a>Github流程</h1><h2 id="创建新仓库并上传"><a href="#创建新仓库并上传" class="headerlink" title="创建新仓库并上传"></a>创建新仓库并上传</h2><ol><li>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220814223830.png" alt=""></li><li><p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220814223907.png" alt=""></p></li><li><p>如果本地没有创建仓库,先在本地运行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li>现在，我们根据GitHub的提示，在本地的learngit仓库下运行命令：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote add origin git@github.com:[username]&#x2F;learngit.git</span><br></pre></td></tr></table></figure><code>username</code>的地方填你的用户名，远程库的名字是<code>origin</code>，这是Git默认的叫法。   </li><li>本地添加git文件，添加缓存区并提交：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git add</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure></li><li>下一步，就可以把本地库的所有内容推送到远程库上：  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push -u origin master</span><br></pre></td></tr></table></figure>把本地库的内容推送到远程，用git push命令，实际上是把当前分支master推送到远程。<br>由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。</li></ol><h2 id="查看缓存区状态"><a href="#查看缓存区状态" class="headerlink" title="查看缓存区状态"></a>查看缓存区状态</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h2 id="删除git分支"><a href="#删除git分支" class="headerlink" title="删除git分支"></a>删除git分支</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">命令：$ git push origin 【空格】【冒号】【需要删除的分支名字】</span><br><span class="line">例：  $ git push origin :main</span><br></pre></td></tr></table></figure><h2 id="删除远程仓库已经提交的文件"><a href="#删除远程仓库已经提交的文件" class="headerlink" title="删除远程仓库已经提交的文件"></a>删除远程仓库已经提交的文件</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit -a</span><br></pre></td></tr></table></figure><blockquote><p>加了-a，在 commit 的时候，能帮你省一步 git add ，但也只是对修改和删除文件有效， 新文件还是要 git add，不然就是 untracked 状态     </p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/xyr05288/article/details/80829679">https://blog.csdn.net/xyr05288/article/details/80829679</a><br><a href="https://blog.csdn.net/taowuhua0505/article/details/80499540">https://blog.csdn.net/taowuhua0505/article/details/80499540</a><br><a href="https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416">https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mosquitto(MQTT)ubuntu搭建教程</title>
      <link href="2021/09/03/mosquitto-tutorial/"/>
      <url>2021/09/03/mosquitto-tutorial/</url>
      
        <content type="html"><![CDATA[<p>Mosquitto是一款实现了 MQTT v3.1 协议的开源消息代理软件，包括了服务器端和客户端，可以跨平台部署，提供轻量级的，支持发布/订阅的的消息推送模式，使设备对设备之间的短消息通信简单易用。以下是在Ubuntu环境下，本地搭建MQTT服务器和客户端</p><h1 id="安装mosquitto"><a href="#安装mosquitto" class="headerlink" title="安装mosquitto"></a>安装mosquitto</h1><h2 id="引入mosquitto仓库并更新"><a href="#引入mosquitto仓库并更新" class="headerlink" title="引入mosquitto仓库并更新"></a>引入mosquitto仓库并更新</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-add-repository ppa:mosquitto-dev/mosquitto-ppa</span><br><span class="line"></span><br><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure><h2 id="安装mosquitto服务器和客户端"><a href="#安装mosquitto服务器和客户端" class="headerlink" title="安装mosquitto服务器和客户端"></a>安装mosquitto服务器和客户端</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mosquitto   #服务端</span><br><span class="line"></span><br><span class="line">sudo apt-get install mosquitto-clients  #客户端（想在windows下测试可以下一个chrome的mqttbox插件）</span><br></pre></td></tr></table></figure><h2 id="开启-停止mosquitto服务"><a href="#开启-停止mosquitto服务" class="headerlink" title="开启/停止mosquitto服务"></a>开启/停止mosquitto服务</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mosquitto start</span><br><span class="line"></span><br><span class="line">sudo service mosquitto stop</span><br></pre></td></tr></table></figure><h2 id="查看mosquitto服务状态"><a href="#查看mosquitto服务状态" class="headerlink" title="查看mosquitto服务状态"></a>查看mosquitto服务状态</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo service mosquitto status </span><br></pre></td></tr></table></figure><p>成功启动如下图：<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201343.png" alt=""></p><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><h2 id="ubuntu使用mosquitto-clients"><a href="#ubuntu使用mosquitto-clients" class="headerlink" title="ubuntu使用mosquitto-clients"></a>ubuntu使用mosquitto-clients</h2><h3 id="打开一个终端，订阅主题"><a href="#打开一个终端，订阅主题" class="headerlink" title="打开一个终端，订阅主题"></a>打开一个终端，订阅主题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mosquitto_sub -h localhost -t &quot;mqtt&quot; -v</span><br></pre></td></tr></table></figure><p>【-h】指定要连接的MQTT服务器<br>【-t】订阅主题，此处为mqtt<br>【-v】打印更多的调试信息  </p><h3 id="打开另一个终端，发布主题"><a href="#打开另一个终端，发布主题" class="headerlink" title="打开另一个终端，发布主题"></a>打开另一个终端，发布主题</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">mosquitto_pub -h localhost -t &quot;mqtt&quot; -m &quot;Hello MQTT&quot;</span><br></pre></td></tr></table></figure><p>【-h】指定要连接的MQTT服务器<br>【-t】向指定主题推送消息<br>【-m】指定消息内容  </p><h2 id="windows下使用mqttBox"><a href="#windows下使用mqttBox" class="headerlink" title="windows下使用mqttBox"></a>windows下使用mqttBox</h2><ol><li>选择creat MQTT client</li><li>设置ip和端口 选择协议<br><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327201512.png" alt="">  </li><li>创建订阅者和发布者开始传输  </li></ol><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://blog.csdn.net/weixin_42411153/article/details/95310684">https://blog.csdn.net/weixin_42411153/article/details/95310684</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQTT </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单片机通信协议总结</title>
      <link href="2021/06/23/MCU-tele/"/>
      <url>2021/06/23/MCU-tele/</url>
      
        <content type="html"><![CDATA[<h1 id="iic通信"><a href="#iic通信" class="headerlink" title="iic通信"></a>iic通信</h1><p>I2C(IIC,Inter－Integrated Circuit), <strong><em>两线式</em></strong> 串行总线,由PHILIPS公司开发用于连接微控制器及其外围设备。<br>它是由 <strong><em>数据线SDA和时钟SCL</em></strong> 构成的串行总线，可发送和接收数据。在CPU与被控IC之间、IC与IC之间进行双向传送，高速IIC总线一般可达400kbps以上。</p><p>IIC是 <strong><em>半双工</em></strong> 通信方式。</p><h2 id="总线结构"><a href="#总线结构" class="headerlink" title="总线结构"></a>总线结构</h2><p>iic通信总线需要拉高，空闲时sda和scl都为高电平，结构如下图：<br><img src="https://www.hualigs.cn/image/60d2b49687c0b.jpg" alt="总线结构"></p><h2 id="iic协议状态"><a href="#iic协议状态" class="headerlink" title="iic协议状态"></a>iic协议状态</h2><h3 id="空闲状态"><a href="#空闲状态" class="headerlink" title="空闲状态"></a>空闲状态</h3><p>I2C总线总线的SDA和SCL两条信号线同时处于 <strong><em>高电平</em></strong> 时，规定为总线的空闲状态。此时各个器件的输出级场效应管均处在截止状态，即释放总线，由两条信号线各自的上拉电阻把电平拉高。 </p><h3 id="起始信号与停止信号"><a href="#起始信号与停止信号" class="headerlink" title="起始信号与停止信号"></a>起始信号与停止信号</h3><ul><li>起始信号：当SCL为高期间，SDA由高到低的跳变；启动信号是一种电平跳变时序信号，而不是一个电平信号。  </li><li>停止信号：当SCL为高期间，SDA由低到高的跳变；停止信号也是一种电平跳变时序信号，而不是一个电平信号。  </li></ul><p><img src="https://www.hualigs.cn/image/60d2b58ef2530.jpg" alt="">  </p><p>代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Start</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();     <span class="comment">//sda设置为输出模式</span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;  <span class="comment">//空闲状态，sda和scl都为高</span></span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line"> IIC_SDA=<span class="number">0</span>;    <span class="comment">//START:when CLK is high,DATA change form high to low </span></span><br><span class="line">delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;    <span class="comment">//钳住iic总线，准备发送或者接收数据</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Stop</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">SDA_OUT();    <span class="comment">//sda输出</span></span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">IIC_SDA=<span class="number">0</span>;    <span class="comment">//STOP:when CLK is high DATA change form low to high</span></span><br><span class="line"> delay_us(<span class="number">4</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>; </span><br><span class="line">IIC_SDA=<span class="number">1</span>;   <span class="comment">// 发送iic总线结束信号</span></span><br><span class="line">delay_us(<span class="number">4</span>);   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="应答信号ACK"><a href="#应答信号ACK" class="headerlink" title="应答信号ACK"></a>应答信号ACK</h3><p>发送器每发送一个字节，就在时钟脉冲9期间释放数据线，由接收器反馈一个应答信号。 应答信号为低电平时，规定为<strong>有效应答位</strong>（ACK简称应答位），表示接收器已经成功地接收了该字节；应答信号为高电平时，规定为<strong>非应答位</strong>（NACK），一般表示接收器接收该字节没有成功。   </p><p><font color=#FF0000>对于反馈有效应答位ACK的要求是，接收器在 <strong>第9个</strong> 时钟脉冲之前的低电平期间将SDA线拉低，并且确保在该时钟的高电平期间为稳定的低电平。</font> 如果接收器是主控器，则在它收到最后一个字节后，发送一个NACK信号，以通知被控发送器结束数据发送，并释放SDA线，以便主控接收器发送一个停止信号P。<br><img src="https://www.hualigs.cn/image/60d2b635eb0f8.jpg" alt=""></p><p>代码：<br><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//等待应答信号到来</span></span><br><span class="line"><span class="comment">//返回值：0为接受成功</span></span><br><span class="line"><span class="comment">//        1为接受失败</span></span><br><span class="line"><span class="function">u8 <span class="title">IIC_Wait_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">u8 ucErrTime=<span class="number">0</span>;</span><br><span class="line">SDA_IN();      <span class="comment">//SDAÉèÖÃÎªÊäÈë  </span></span><br><span class="line">IIC_SDA=<span class="number">1</span>;delay_us(<span class="number">1</span>);   </span><br><span class="line">IIC_SCL=<span class="number">1</span>;delay_us(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">while</span>(READ_SDA)</span><br><span class="line">&#123;</span><br><span class="line">ucErrTime++;</span><br><span class="line"><span class="keyword">if</span>(ucErrTime&gt;<span class="number">250</span>)</span><br><span class="line">&#123;</span><br><span class="line">IIC_Stop();</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;<span class="comment">//Ê±ÖÓÊä³ö0    </span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">//产生ack应答</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_Ack</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();  <span class="comment">//输出模式</span></span><br><span class="line">IIC_SDA=<span class="number">0</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//不产生应答    </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IIC_NAck</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">SDA_OUT();</span><br><span class="line">IIC_SDA=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">1</span>;</span><br><span class="line">delay_us(<span class="number">2</span>);</span><br><span class="line">IIC_SCL=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="数据有效性"><a href="#数据有效性" class="headerlink" title="数据有效性"></a>数据有效性</h3><p>I2C总线进行数据传送时，时钟信号为高电平期间，数据线上的数据必须保持稳定，只有在时钟线上的信号为低电平期间，数据线上的高电平或低电平状态才允许变化。   </p><p><font color=#ff0000>即：数据在SCL的上升沿到来之前就需准备好。并在在下降沿到来之前必须稳定。</font><br><img src="https://www.hualigs.cn/image/60d2b70984c8c.jpg" alt=""></p><h3 id="数据的传送"><a href="#数据的传送" class="headerlink" title="数据的传送"></a>数据的传送</h3><p>在I2C总线上传送的每一位数据都有一个时钟脉冲相对应（或同步控制），即在SCL串行时钟的配合下，在SDA上逐位地串行传送每一位数据。数据位的传输是边沿触发。</p>]]></content>
      
      
      <categories>
          
          <category> Sheet </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mcu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stm32时钟系统</title>
      <link href="2021/06/18/stm32-timer/"/>
      <url>2021/06/18/stm32-timer/</url>
      
        <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/2019080810214187.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzNDgwMTMzOTM3,size_16,color_FFFFFF,t_70" alt="stm32时钟树"></p><ol><li>STM32 有5个时钟源:HSI、HSE、LSI、LSE、PLL。   <ul><li>HSI是高速内部时钟，RC振荡器，频率为16MHz，精度不高。可以直接作为系统<br>时钟或者用作PLL时钟输入。       </li><li>HSE是高速外部时钟，可接石英/陶瓷谐振器，或者接外部时钟源，频率范围为4MHz~26MHz。   </li><li>LSI是低速内部时钟，RC振荡器，频率为32kHz，提供低功耗时钟。主要供独立看    门狗和自动唤醒单元使用。    </li><li>LSE是低速外部时钟，接频率为32.768kHz的石英晶体。RTC    　 </li><li>PLL为锁相环倍频输出。STM32F4有两个PLL:   <ul><li>主PLL(PLL)由HSE或者HSI提供时钟信号，并具有两个不同的输出时钟。  <ul><li>第一个输出PLLP用于生成高速的系统时钟（最高168MHz）    </li><li>第二个输出PLLQ用于生成USB OTG FS的时钟（48MHz），随机数发生器的时钟和SDIO时钟。  </li></ul></li><li>专用PLL(PLLI2S)用于生成精确时钟，从而在I2S接口实现高品质音频性能。</li></ul></li></ul></li></ol><ol><li>系统时钟SYSCLK可来源于三个时钟源：  <ul><li>HSI振荡器时钟  </li><li>HSE振荡器时钟  </li><li>PLL时钟  </li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> stm32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32命名规则</title>
      <link href="2021/06/15/STM32-name/"/>
      <url>2021/06/15/STM32-name/</url>
      
        <content type="html"><![CDATA[<p><img src="https://lpblog-1259256967.cos.ap-chengdu.myqcloud.com/blog/20220327202912.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>arduinoIDE导入esp32开发板方法</title>
      <link href="2021/06/02/esp32-arduinoIDE/"/>
      <url>2021/06/02/esp32-arduinoIDE/</url>
      
        <content type="html"><![CDATA[<h1 id="Arduino环境配置"><a href="#Arduino环境配置" class="headerlink" title="Arduino环境配置"></a>Arduino环境配置</h1><p>首先我们要先去下载Arduino，大家可以去官网下，也可以在Arduino中文社区进行下载，这是中文社区网址<a href="https://www.arduino.cn/">https://www.arduino.cn/</a>。</p><p><img src="https://www.hualigs.cn/image/60b720e41b38a.jpg" alt=""></p><h1 id="Arduino添加esp32开发板"><a href="#Arduino添加esp32开发板" class="headerlink" title="Arduino添加esp32开发板"></a>Arduino添加esp32开发板</h1><p>两种方法，arduinoIDE中直接下载，或者使用源码下载：</p><h2 id="方法一（arduino中下载）："><a href="#方法一（arduino中下载）：" class="headerlink" title="方法一（arduino中下载）："></a>方法一（arduino中下载）：</h2><p>文件&gt;首选项&gt;附加开发板管理器网址 中加入Arduino for esp的地址:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;dl.espressif.com&#x2F;dl&#x2F;package_esp32_index.json</span><br><span class="line">http:&#x2F;&#x2F;arduino.esp8266.com&#x2F;stable&#x2F;package_esp8266com_index.json</span><br></pre></td></tr></table></figure></p><p><img src="https://i0.hdslb.com/bfs/album/eb3de20abbb0e63b4dcfb9f88918c3232cb3646c.gif" alt=""></p><p>完成网址添加后就可以在：工具&gt;开发板&gt;开发板管理器 中搜索并下载esp32开发板数据包（版本选1.0.2）:</p><p><img src="https://i0.hdslb.com/bfs/album/dd41db11f4caa1d9d5b718278ead80863b93ebb6.gif" alt=""></p><h3 id="出错记录"><a href="#出错记录" class="headerlink" title="出错记录"></a>出错记录</h3><font color=#FF0000>这里的版本最好要选1.0.2!!!!!!!</font>  <p>我最开始用的最新1.0.6版本，烧录esp32cam的示例无法正常运行，换成1.0.2就好了</p><p><img src="https://www.hualigs.cn/image/60b7826762a8e.jpg" alt=""></p><h2 id="方法二（源码下载）："><a href="#方法二（源码下载）：" class="headerlink" title="方法二（源码下载）："></a>方法二（源码下载）：</h2><p>先去github下载源码：</p><p><a href="https://github.com/espressif/arduino-esp32/">https://github.com/espressif/arduino-esp32/</a></p><p>在arduino的安装目录下找到hardware，新建espressif，再在里面新建esp32，然后把下载的压缩包全都放在目录下面</p><p><img src="https://www.hualigs.cn/image/60b72bbe84d25.jpg" alt=""></p><p>打开当前文件夹的tools目录，运行get.exe。然后重启arduino即可。</p><p><img src="https://www.hualigs.cn/image/60b72ca087f3a.jpg" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> esp32 </tag>
            
            <tag> arduino </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>apache2启动报错排查</title>
      <link href="2021/05/31/apache2-err/"/>
      <url>2021/05/31/apache2-err/</url>
      
        <content type="html"><![CDATA[<h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><p>阿里云ubuntu版本：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">LSB Version:    core-11.1.0ubuntu2-noarch:security-11.1.0ubuntu2-noarch</span><br><span class="line">Distributor ID: Ubuntu</span><br><span class="line">Description:    Ubuntu 20.04.1 LTS</span><br><span class="line">Release:        20.04</span><br><span class="line">Codename:       focal</span><br></pre></td></tr></table></figure><br>apache:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Server version: Apache&#x2F;2.4.41 (Ubuntu)</span><br><span class="line">Server built:   2020-08-12T19:46:17</span><br></pre></td></tr></table></figure></p><h2 id="报错"><a href="#报错" class="headerlink" title="报错"></a>报错</h2><p>修改apache的配置文件后，重启apache会报错<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#service apache2 restart</span><br><span class="line"></span><br><span class="line">Job for apache2.service failed because the control process exited with error code.</span><br><span class="line">See &quot;systemctl status apache2.service&quot; and &quot;journalctl -xe&quot; for details.</span><br></pre></td></tr></table></figure><br>这个时候不要慌！不要重装！不要放弃！按照提示运行:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl status apache2.service</span><br></pre></td></tr></table></figure></p><h2 id="我这里出现过的错误："><a href="#我这里出现过的错误：" class="headerlink" title="我这里出现过的错误："></a>我这里出现过的错误：</h2><h3 id="错误1："><a href="#错误1：" class="headerlink" title="错误1："></a>错误1：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● apache2.service - The Apache HTTP Server</span><br><span class="line">     Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;apache2.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Mon 2021-05-31 21:00:24 CST; 3s ago</span><br><span class="line">       Docs: https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;</span><br><span class="line">    Process: 1184602 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;apachectl start (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)</span><br><span class="line"></span><br><span class="line">May 31 21:00:23 iZwz919g91pglb4zkj97ctZ systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184611]: apache2: Syntax error on line 225 of &#x2F;etc&#x2F;apache2&#x2F;apache2.conf: Syntax error on line 34 of &#x2F;etc&#x2F;apach&gt;</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184602]: Action &#39;start&#39; failed.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ apachectl[1184602]: The Apache error log may have more information.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Control process exited, code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Failed with result &#39;exit-code&#39;.</span><br><span class="line">May 31 21:00:24 iZwz919g91pglb4zkj97ctZ systemd[1]: Failed to start The Apache HTTP Server.</span><br></pre></td></tr></table></figure><p>看后面log的第二行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apache2: Syntax error on line 225 of &#x2F;etc&#x2F;apache2&#x2F;apache2.conf: Syntax error on line 34 of &#x2F;etc&#x2F;apach&gt;</span><br></pre></td></tr></table></figure><br>进入配置文件中查看34行的错误，具体情况具体分析</p><h3 id="错误2："><a href="#错误2：" class="headerlink" title="错误2："></a>错误2：</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">● apache2.service - The Apache HTTP Server</span><br><span class="line">     Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;apache2.service; enabled; vendor preset: enabled)</span><br><span class="line">     Active: failed (Result: exit-code) since Mon 2021-05-31 21:04:16 CST; 14s ago</span><br><span class="line">       Docs: https:&#x2F;&#x2F;httpd.apache.org&#x2F;docs&#x2F;2.4&#x2F;</span><br><span class="line">    Process: 1184995 ExecStart&#x3D;&#x2F;usr&#x2F;sbin&#x2F;apachectl start (code&#x3D;exited, status&#x3D;1&#x2F;FAILURE)</span><br><span class="line"></span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: Starting The Apache HTTP Server...</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: AH00526: Syntax error on line 37 of &#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default-ssl.conf:</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: Invalid command &#39;ProxyRequests&#39;, perhaps misspelled or defined by a module not included in the server&gt;</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1184995]: Action &#39;start&#39; failed.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1184995]: The Apache error log may have more information.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Control process exited, code&#x3D;exited, status&#x3D;1&#x2F;FAILURE</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: apache2.service: Failed with result &#39;exit-code&#39;.</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ systemd[1]: Failed to start The Apache HTTP Server.</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>依旧是看log的第二行,这次加上第三行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: AH00526: Syntax error on line 37 of &#x2F;etc&#x2F;apache2&#x2F;sites-enabled&#x2F;000-default-ssl.conf:</span><br><span class="line">May 31 21:04:16 iZwz919g91pglb4zkj97ctZ apachectl[1185012]: Invalid command &#39;ProxyRequests&#39;, perhaps misspelled or defined by a module not included in the server&gt;</span><br></pre></td></tr></table></figure><br>得知ProxyRequests模块未定义，这里是因为我配置了反向代理，然而它找不到模块。只需开启一下代理模块。</p><p>运行：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a2enmod proxy </span><br></pre></td></tr></table></figure><br>然后：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl restart apache2</span><br></pre></td></tr></table></figure><br>OK,成功运行！</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> apache2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo butterfly视频自适应</title>
      <link href="2021/05/21/hexo-butterfly-video/"/>
      <url>2021/05/21/hexo-butterfly-video/</url>
      
        <content type="html"><![CDATA[<p>想在文章中放入视频 结果发现放进去是这样的：<br>(在.md文件里放视频的方法：<a href="https://callmelp.online/2021/05/19/markdown/#%E8%A7%86%E9%A2%91">https://callmelp.online/2021/05/19/markdown/#%E8%A7%86%E9%A2%91</a>)</p><p>youtube：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">width</span>=<span class="string">&quot;560&quot;</span> <span class="attr">height</span>=<span class="string">&quot;315&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://www.youtube.com/embed/FuKEpOhiVPg&quot;</span> <span class="attr">title</span>=<span class="string">&quot;YouTube video player&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allow</span>=<span class="string">&quot;accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture&quot;</span> <span class="attr">allowfullscreen</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><div>    <iframe width="560" height="315" src="https://www.youtube.com/embed/FuKEpOhiVPg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div><p>bilibili：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=672887323&amp;bvid=BV1sU4y187Lv&amp;cid=333761412&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure></p><div>    <iframe src="//player.bilibili.com/player.html?aid=672887323&bvid=BV1sU4y187Lv&cid=333761412&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h1 id="改进的后效果"><a href="#改进的后效果" class="headerlink" title="改进的后效果"></a>改进的后效果</h1><p>原理就是改一下css代码，让div的宽度为100%，然后视频在div里铺开的效果：</p><p>youtube:</p><div class="video">    <iframe width="560" height="315" src="https://www.youtube.com/embed/FuKEpOhiVPg" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div><p>bilibili:</p><div class="video">    <iframe src="//player.bilibili.com/player.html?aid=672887323&bvid=BV1sU4y187Lv&cid=333761412&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div><h1 id="操作方法"><a href="#操作方法" class="headerlink" title="操作方法"></a>操作方法</h1><h2 id="新建css"><a href="#新建css" class="headerlink" title="新建css"></a>新建css</h2><p>首先在主题文件夹下<code>source/css</code>里面创建一个<code>video.css</code>的文件，填入：</p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*视频适配*/</span></span><br><span class="line"><span class="selector-class">.video</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;              <span class="comment">/*高度设置这里无效，设置为0，用padding撑开div*/</span></span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">75%</span>;    <span class="comment">/*68%到80%都可以*/</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.video</span> <span class="selector-tag">iframe</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="主题配置里引入css"><a href="#主题配置里引入css" class="headerlink" title="主题配置里引入css"></a>主题配置里引入css</h2><p>打开主题的配置文件，搜索<code>inject</code>：</p><p><img src="https://www.hualigs.cn/image/60a7ded26c262.jpg" alt=""></p><p>我们在head一栏增加下面的内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- &lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#x2F;css&#x2F;video.css&quot;&gt;  </span><br></pre></td></tr></table></figure></p><h2 id="插入视频"><a href="#插入视频" class="headerlink" title="插入视频"></a>插入视频</h2><p>接下来就可以在.md文件里插入适应屏幕视频了：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;video&quot;</span>&gt;</span>        //注意这里的div里要设置class</span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;//player.bilibili.com/player.html?aid=18316187&amp;bvid=BV1tW411q7KM&amp;cid=40592634&amp;page=1&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>OK, 这样手机端和PC端都能适配了。</p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown使用教程</title>
      <link href="2021/05/19/markdown/"/>
      <url>2021/05/19/markdown/</url>
      
        <content type="html"><![CDATA[<p>markdown的详细使用方法<br><span id="more"></span></p><h2 id="目录"><a href="#目录" class="headerlink" title="目录 "></a><strong>目录</strong> </h2><ul><li><a href="#markdown标题">Markdown标题</a><ul><li><a href="#1-和-标记一二级标题">1. =和-标记一二级标题</a></li><li><a href="#2-使用--号标题">2. 使用 # 号标题</a></li></ul></li><li><a href="#markdown分割线">Markdown分割线</a></li><li><a href="#markdown字体">Markdown字体</a><ul><li><a href="#删除线">删除线</a></li><li><a href="#下划线">下划线</a></li><li><a href="#脚注">脚注</a></li><li><a href="#表情github版本">表情（Github版本）</a></li></ul></li><li><a href="#markdown段落">Markdown段落</a></li><li><a href="#markdown-目录跳转">MarkDown 目录跳转</a></li><li><a href="#markdown列表">Markdown列表</a><ul><li><a href="#无序列表">无序列表</a></li><li><a href="#有序列表">有序列表</a></li><li><a href="#列表嵌套">列表嵌套</a></li><li><a href="#区块">区块</a></li><li><a href="#复选框列表github版本">复选框列表（Github版本）</a></li></ul></li><li><a href="#markdown代码">Markdown代码</a><ul><li><a href="#代码区块">代码区块</a></li></ul></li><li><a href="#markdown链接">Markdown链接</a><ul><li><a href="#高级链接">高级链接</a></li><li><a href="#用户提醒">用户@提醒</a></li></ul></li><li><a href="#markdown图片和视频">Markdown图片和视频</a><ul><li><a href="#视频">视频</a></li></ul></li><li><a href="#markdown-表格">Markdown 表格</a><ul><li><a href="#对齐方式">对齐方式</a></li></ul></li><li><a href="#markdown-高级技巧">Markdown 高级技巧</a><ul><li><a href="#支持的-html-元素">支持的 HTML 元素</a></li><li><a href="#转义">转义</a></li><li><a href="#导出pdf分页">导出pdf分页</a></li></ul></li><li><a href="#github-badge">GitHub-badge</a><ul><li><a href="#静态badge">静态badge</a></li><li><a href="#动态实时更新badge">动态实时更新badge</a></li></ul></li></ul><h1 id="Markdown标题"><a href="#Markdown标题" class="headerlink" title="Markdown标题"></a>Markdown标题</h1><h2 id="1-和-标记一二级标题"><a href="#1-和-标记一二级标题" class="headerlink" title="1. =和-标记一二级标题"></a>1. =和-标记一二级标题</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">一级标题</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">二级标题</span><br><span class="line">--------------</span><br></pre></td></tr></table></figure><p>效果(示例添加区块以区分)：  </p><blockquote><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2></blockquote><h2 id="2-使用-号标题"><a href="#2-使用-号标题" class="headerlink" title="2. 使用 # 号标题"></a>2. 使用 # 号标题</h2><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题</span><br></pre></td></tr></table></figure><blockquote><h1 id="一级标题-1"><a href="#一级标题-1" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题-1"><a href="#二级标题-1" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6></blockquote><h1 id="Markdown分割线"><a href="#Markdown分割线" class="headerlink" title="Markdown分割线"></a>Markdown分割线</h1><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">***</span><br><span class="line"></span><br><span class="line">* * *</span><br><span class="line"></span><br><span class="line">*****</span><br><span class="line"></span><br><span class="line">- - -</span><br><span class="line"></span><br><span class="line">----------</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><hr><hr><hr><hr><hr></blockquote><h1 id="Markdown字体"><a href="#Markdown字体" class="headerlink" title="Markdown字体"></a>Markdown字体</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">*斜体文本*</span><br><span class="line">_斜体文本_</span><br><span class="line">**粗体文本**</span><br><span class="line">__粗体文本__</span><br><span class="line">***粗斜体文本***</span><br><span class="line">___粗斜体文本___</span><br></pre></td></tr></table></figure><p>显示效果如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/md3.gif" width="100%"></p><h2 id="删除线"><a href="#删除线" class="headerlink" title="删除线"></a>删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~~hello world~~</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p><del>hello world</del></p></blockquote><h2 id="下划线"><a href="#下划线" class="headerlink" title="下划线"></a>下划线</h2><p>通过 HTML 的 \<u> 标签来实现<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;u&gt;hello world&lt;&#x2F;u&gt;</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p><u>hello world</u></p></blockquote><h2 id="脚注"><a href="#脚注" class="headerlink" title="脚注"></a>脚注</h2><p>脚注是对文本的补充说明。</p><p>Markdown 脚注的格式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure><br>示例：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建脚注格式类似这样 [^tip]。</span><br><span class="line"></span><br><span class="line">[^tip]: 这是一个脚注。</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><p>创建脚注格式类似这样 <sup><a href="#fn_TIP" id="reffn_TIP">TIP</a></sup>。</p><blockquote id="fn_TIP"><sup>TIP</sup>.  这是一个脚注。<a href="#reffn_TIP" title="Jump back to footnote [TIP] in the text."> &#8617;</a></blockquote></blockquote><p>备注：目前Github原生的issue和markdown预览不支持标准md格式的脚注，可以用锚点的特性+上标标签实现相似的功能，参照维基百科的格式，可以这么做：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">文章内容&lt;sup id&#x3D;&quot;a1&quot;&gt;[[1]](#f1)&lt;&#x2F;sup&gt;</span><br><span class="line"></span><br><span class="line">&lt;span id&#x3D;&quot;f1&quot;&gt;1. [^](#a1)&lt;&#x2F;span&gt; 脚注1的说明</span><br></pre></td></tr></table></figure></p><h2 id="表情（Github版本）"><a href="#表情（Github版本）" class="headerlink" title="表情（Github版本）"></a>表情（Github版本）</h2><p>Github的Markdown语法支持添加emoji表情，输入不同的符号码（两个冒号包围的字符）可以显示出不同的表情。</p><p>比如<code>:smile:</code>可以显示 :smile:</p><p>具体每一个表情的符号码，可以查询GitHub的官方网页<a href="https://www.webfx.com/tools/emoji-cheat-sheet/">https://www.webfx.com/tools/emoji-cheat-sheet/</a></p><h1 id="Markdown段落"><a href="#Markdown段落" class="headerlink" title="Markdown段落"></a>Markdown段落</h1><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/36A89BDA-A062-4D66-A41B-0EBEE7891AB9.jpg" width="100%"></p><p>当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><p><img src="https://www.runoob.com/wp-content/uploads/2019/03/3F254936-778E-417A-BEF2-467116A55D00.jpg" width="100%"></p><h1 id="MarkDown-目录跳转"><a href="#MarkDown-目录跳转" class="headerlink" title="MarkDown 目录跳转"></a>MarkDown 目录跳转</h1><p>MarkDown中是通过定义链接的方式来定义跳转的，在这里，跳转也称为<code>锚点</code>，跳转的目标称为<code>锚点目标</code>；</p><p>所以，在 MarkDown 中实现页面内跳转的方法就是：定义一个<code>锚点目标</code>和对应的<code>锚点</code>，用户点击<code>锚点</code>便可跳转到对应的<code>锚点目标</code>位置处；</p><p>语法：</p><pre><code>锚点 = [内容](#标题)</code></pre><ul><li>标题 是可选的，可以用单引号 或 双引号；  </li></ul><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">对于标题#Hello</span><br><span class="line">正确的链接方式是[Hello](#hello)</span><br><span class="line"></span><br><span class="line">对于标题 #Hello World</span><br><span class="line">正确的链接方式为[Hello World](#hello-world)</span><br><span class="line"></span><br><span class="line">注意：()中的字母均为小写，单词之间有间隔用 &#39;-&#39; 连接</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Contents  </span><br><span class="line">- [Abstract](#abstract)  </span><br><span class="line">- [Preface](#preface)  </span><br><span class="line">- [Design idea and innovation point](#design-idea-and-innovation-point)  </span><br><span class="line">  - [Background](#background) </span><br><span class="line">  - [Design inspirations](#design-inspirations) </span><br><span class="line">  - [Innovation point](#innovation-point)  </span><br><span class="line">  - [Developmental vision](#developmental-vision) </span><br></pre></td></tr></table></figure><blockquote><h1 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h1><ul><li><a href="#abstract">Abstract</a>  </li><li><a href="#preface">Preface</a>  </li><li><a href="#design-idea-and-innovation-point">Design idea and innovation point</a>  <ul><li><a href="#background">Background</a> </li><li><a href="#design-inspirations">Design inspirations</a> </li><li><a href="#innovation-point">Innovation point</a>  </li><li><a href="#developmental-vision">Developmental vision</a> </li></ul></li></ul></blockquote><h1 id="Markdown列表"><a href="#Markdown列表" class="headerlink" title="Markdown列表"></a>Markdown列表</h1><p>Markdown 支持<u>有序列表</u>和<u>无序列表</u>。</p><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><p>无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记，这些标记后面要添加一个<u>空格</u>，然后再填写内容：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 第一项</span><br><span class="line">* 第二项</span><br><span class="line">* 第三项</span><br><span class="line"></span><br><span class="line">+ 第一项</span><br><span class="line">+ 第二项</span><br><span class="line">+ 第三项</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 第一项</span><br><span class="line">- 第二项</span><br><span class="line">- 第三项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><p>有序列表使用数字并加上 . 号来表示，如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项</span><br><span class="line">2. 第二项</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>第一项</li><li>第二项</li></ol></blockquote><h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><p>列表嵌套只需在子列表中的选项前面添加四个空格即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. 第一项：</span><br><span class="line">    - 第一项嵌套的第一个元素</span><br><span class="line">    - 第一项嵌套的第二个元素</span><br><span class="line">2. 第二项：</span><br><span class="line">    - 第二项嵌套的第一个元素</span><br><span class="line">    - 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol></blockquote><h2 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h2><p>Markdown 区块引用是在段落开头使用 &gt; 符号 ，然后后面紧跟一个空格符号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure><br>效果（本文效果全部默认添加区块以区分）：</p><blockquote><blockquote><p>hello world</p></blockquote></blockquote><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; 最外层</span><br><span class="line">&gt; &gt; 第一层嵌套</span><br><span class="line">&gt; &gt; &gt; 第二层嵌套</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote></blockquote><p>备注：区块和列表可互相嵌套</p><h2 id="复选框列表（Github版本）"><a href="#复选框列表（Github版本）" class="headerlink" title="复选框列表（Github版本）"></a>复选框列表（Github版本）</h2><p>语法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- [x] 需求分析</span><br><span class="line">- [x] 系统设计</span><br><span class="line">- [x] 详细设计</span><br><span class="line">- [ ] 编码</span><br><span class="line">- [ ] 测试</span><br><span class="line">- [ ] 交付</span><br></pre></td></tr></table></figure><blockquote><ul><li>[x] 需求分析</li><li>[x] 系统设计</li><li>[x] 详细设计</li><li>[ ] 编码</li><li>[ ] 测试</li><li>[ ] 交付</li></ul></blockquote><p>您可以使用这个功能来标注某个项目各项任务的完成情况。</p><blockquote><p>Tip:<br>在GitHub的issue中使用该语法是可以实时点击复选框来勾选或解除勾选的，而无需修改issue原文。</p></blockquote><h1 id="Markdown代码"><a href="#Markdown代码" class="headerlink" title="Markdown代码"></a>Markdown代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;printf()&#96; 函数</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><code>printf()</code> 函数</p></blockquote><h2 id="代码区块"><a href="#代码区块" class="headerlink" title="代码区块"></a>代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键），例如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">printf()</span><br><span class="line">printf()</span><br></pre></td></tr></table></figure></p><p>效果：</p><blockquote><pre><code>printf()printf()</code></pre></blockquote><p>你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定,指定语言后可显示代码高亮）。Github版本：我们使用 <a href="https://github.com/github/linguist">Linguist</a> 来进行语言识别和语法着色。你可以在 <a href="https://github.com/github/linguist/blob/master/lib/linguist/languages.yml">语言 YAML 文件</a> 中查证哪些语言标识符是有效的。：</p><pre><code><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></code></pre><p>效果：</p><blockquote><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    alert(<span class="string">&#x27;RUNOOB&#x27;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></blockquote><h1 id="Markdown链接"><a href="#Markdown链接" class="headerlink" title="Markdown链接"></a>Markdown链接</h1><p>链接使用方法如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[链接名称](链接地址)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><p>例如：</p><pre><code>这是一个链接[Baidu](https://www.baidu.com)</code></pre><p>效果：</p><blockquote><p>这是一个链接<a href="https://www.baidu.com">Baidu</a></p></blockquote><p>直接使用链接地址：</p><pre><code>&lt;https://www.baidu.com&gt;</code></pre><p>效果：</p><blockquote><p><a href="https://www.baidu.com">https://www.baidu.com</a></p></blockquote><h2 id="高级链接"><a href="#高级链接" class="headerlink" title="高级链接"></a>高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Google][1]</span><br><span class="line"></span><br><span class="line">这个链接用 2 作为网址变量 [Baidu][2]</span><br><span class="line"></span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: https:&#x2F;&#x2F;www.google.com&#x2F;</span><br><span class="line">  [2]: https:&#x2F;&#x2F;www.Baidu.com&#x2F;</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这个链接用 1 作为网址变量 [Google][1]</p><p>这个链接用 2 作为网址变量 [Baidu][2]</p><p>然后在文档的结尾为变量赋值（网址）</p><p>  [1]: <a href="https://www.google.com/">https://www.google.com/</a></p><p>  [2]: <a href="https://www.Baidu.com/">https://www.Baidu.com/</a></p></blockquote><h2 id="用户-提醒"><a href="#用户-提醒" class="headerlink" title="用户@提醒"></a>用户@提醒</h2><p>输入一个@符号，后面跟着一个用户名，会通知那个人来查看评论。 这被称为“@mention” ，因为你提到的是个人。 你也可以@提及组织中的团队。</p><h1 id="Markdown图片和视频"><a href="#Markdown图片和视频" class="headerlink" title="Markdown图片和视频"></a>Markdown图片和视频</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![alt 属性文本](图片地址)</span><br><span class="line"></span><br><span class="line">![alt 属性文本](图片地址 &quot;可选标题&quot;)</span><br></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![RUNOOB 图标](https:&#x2F;&#x2F;ss3.bdstatic.com&#x2F;70cFv8Sh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;441386068,2531499737&amp;fm&#x3D;11&amp;gp&#x3D;0.jpg)</span><br><span class="line"></span><br><span class="line">![RUNOOB 图标](https:&#x2F;&#x2F;ss3.bdstatic.com&#x2F;70cFv8Sh_Q1YnxGkpoWK1HF6hhy&#x2F;it&#x2F;u&#x3D;441386068,2531499737&amp;fm&#x3D;11&amp;gp&#x3D;0.jpg &quot;Baidu&quot;)</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg" alt="Baidu 图标"></p><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg" alt="Baidu 图标" title="Baidu"></p></blockquote><p>你也可以像网址那样对图片网址使用变量:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [Baidu][1].</span><br><span class="line"></span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">[1]: https:&#x2F;&#x2F;www.baidu.com</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p>这个链接用 1 作为网址变量 [Baidu][1].</p><p>然后在文档的结尾为变量赋值（网址）</p><p>[1]: <a href="https://www.baidu.com">https://www.baidu.com</a></p></blockquote><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 \<img> 标签。</p><p>示例（将图片缩小到50%）：</p><pre><code>&lt;img src=&quot;https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&amp;fm=11&amp;gp=0.jpg&quot; width=&quot;50%&quot;&gt;</code></pre><p>效果：</p><blockquote><p><img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=441386068,2531499737&fm=11&gp=0.jpg" width="50%"></p></blockquote><h2 id="视频"><a href="#视频" class="headerlink" title="视频"></a>视频</h2><p>插入视频标签：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;bilibili&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;这里是链接地址&quot;</span> <span class="attr">scrolling</span>=<span class="string">&quot;no&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;no&quot;</span> <span class="attr">framespacing</span>=<span class="string">&quot;0&quot;</span> <span class="attr">allowfullscreen</span>=<span class="string">&quot;true&quot;</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果： </p><blockquote><div class="bilibili">   <iframe src="//player.bilibili.com/player.html?aid=587752666&bvid=BV1NB4y1c7sN&cid=332373513&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe></div></blockquote><h1 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><div class="table-container"><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table></div></blockquote><h2 id="对齐方式"><a href="#对齐方式" class="headerlink" title="对齐方式"></a>对齐方式</h2><p>我们可以设置表格的对齐方式：</p><ul><li><code>-:</code> 设置内容和标题栏居右对齐。</li><li><code>:-</code> 设置内容和标题栏居左对齐。</li><li><code>:-:</code> 设置内容和标题栏居中对齐。</li></ul><p>示例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 111 | 21 | 321231 |</span><br><span class="line">| 24241242442 | 3213123 | 4 |</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><div class="table-container"><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">111</td><td style="text-align:right">21</td><td style="text-align:center">321231</td></tr><tr><td style="text-align:left">24241242442</td><td style="text-align:right">3213123</td><td style="text-align:center">4</td></tr></tbody></table></div></blockquote><h1 id="Markdown-高级技巧"><a href="#Markdown-高级技巧" class="headerlink" title="Markdown 高级技巧"></a>Markdown 高级技巧</h1><h2 id="支持的-HTML-元素"><a href="#支持的-HTML-元素" class="headerlink" title="支持的 HTML 元素"></a>支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。</p><p>目前支持的 HTML 元素有：\<kbd> \<b> \<i> \<em> \<sup> \<sub> \<br>等 ，如：</p><pre><code>使用 &lt;kbd&gt;Ctrl&lt;/kbd&gt;+&lt;kbd&gt;Alt&lt;/kbd&gt;+&lt;kbd&gt;Del&lt;/kbd&gt; 重启电脑</code></pre><p>效果：</p><blockquote><p>使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p></blockquote><h2 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**文本加粗** </span><br><span class="line">\*\* 正常显示星号 \*\*</span><br></pre></td></tr></table></figure><p>效果：</p><blockquote><p><strong>文本加粗</strong> </p><p>** 正常显示星号 **</p></blockquote><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\   反斜线</span><br><span class="line">&#96;   反引号</span><br><span class="line">*   星号</span><br><span class="line">_   下划线</span><br><span class="line">&#123;&#125;  花括号</span><br><span class="line">[]  方括号</span><br><span class="line">()  小括号</span><br><span class="line">#   井字号</span><br><span class="line">+   加号</span><br><span class="line">-   减号</span><br><span class="line">.   英文句点</span><br><span class="line">!   感叹号</span><br></pre></td></tr></table></figure></p><h2 id="导出pdf分页"><a href="#导出pdf分页" class="headerlink" title="导出pdf分页"></a>导出pdf分页</h2><p>在markdown文本中需要分页的地方添入：<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">STYLE</span>=<span class="string">&quot;page-break-after: always;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><br>在Preview窗口不能看到分页的效果， 但是先将markdown文件存为html形式的文件， 然后在输出的pdf文件中的确完成了分页。</p><h1 id="GitHub-badge"><a href="#GitHub-badge" class="headerlink" title="GitHub-badge"></a>GitHub-badge</h1><h2 id="静态badge"><a href="#静态badge" class="headerlink" title="静态badge"></a>静态badge</h2><p>效果如下：</p><p><img src="https://img-blog.csdnimg.cn/20201203142044103.png" alt=""></p><p>badge生成网站：</p><p><a href="https://shields.io/">https://shields.io/</a></p><p>进入网站后找到your badge，填入左边标签、右边标签和颜色后可生成：</p><p><img src="https://cdn.sspai.com/editor/u_spencerwoo/15846965978682.png?imageView2/2/w/1120/q/90/interlace/1/ignore-error/1" alt=""></p><p>将生成的链接放在链接图片链接框中即可：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![](https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;LP-markdown-green)</span><br></pre></td></tr></table></figure><p>也可直接修改链接得到：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">https:&#x2F;&#x2F;img.shields.io&#x2F;badge&#x2F;&#123;左半部分标签&#125;-&#123;右半部分标签&#125;-&#123;右半部分颜色&#125;</span><br></pre></td></tr></table></figure></p><h2 id="动态实时更新badge"><a href="#动态实时更新badge" class="headerlink" title="动态实时更新badge"></a>动态实时更新badge</h2><p>Shields.io 生成的小牌子完全支持动态数据显示，比如粉丝、关注者数量、RSS 订阅者数量……</p><p>动态更新需要可查看<a href="https://sspai.com/post/59593">此链接</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名解析教程</title>
      <link href="2021/05/18/domain/"/>
      <url>2021/05/18/domain/</url>
      
        <content type="html"><![CDATA[<h1 id="域名解析教程"><a href="#域名解析教程" class="headerlink" title="域名解析教程"></a>域名解析教程</h1><p>访问一个网站输入域名，比如<code>www.baidu.com</code>就可以访问到百度。但是我们在浏览器输入<code>www.baidu.com</code>之后是怎么访问到百度的网页的呢？百度的网页存在服务器里，但是我们并不知道他的服务器在哪？</p><span id="more"></span><p>其实就是通过DNS解析到的服务器IP，找到服务器IP之后，我们访问<code>www.baidu.com</code>这个访问请求，就会发给百度的服务器，百度的服务器接收到请求，给你返回了对应的内容，然后我们浏览器收到了内容就给你显示了出来，我们就看到了百度的网页。  </p><p>我们要做的域名解析就是要把域名和IP的对应关系告诉DNS，DNS记下来后有访客访问就返回给他了。<br>不同服务商解析域名的方法大差不差，这里使用腾讯云进行解析讲解</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#所需材料">所需材料</a></li><li><a href="#域名解析">域名解析</a><ul><li><a href="#主机记录">主机记录</a></li><li><a href="#记录类型">记录类型</a></li></ul></li><li><a href="#ssl证书">SSL证书</a><ul><li><a href="#腾讯云ssl证书">腾讯云SSL证书</a></li></ul></li></ul><h2 id="所需材料"><a href="#所需材料" class="headerlink" title="所需材料"></a>所需材料</h2><ol><li>已实名和备案的域名(我们解析的ip地址在国内，所以域名必须通过备案)</li><li>一台公网ip服务器</li></ol><h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>进如腾讯云的<a href="https://console.cloud.tencent.com/domain">域名控制台</a>,点击域名后面的解析。</p><p><img src="https://www.hualigs.cn/image/60a34aa10190f.jpg" alt=""></p><p>进入dnspod（腾讯云的是这个，不同服务商的dns解析不一样）</p><p><img src="https://www.hualigs.cn/image/60a34b9e4b139.jpg" alt=""></p><p>接下来讲一下解析记录里参数都是干啥的</p><h3 id="主机记录"><a href="#主机记录" class="headerlink" title="主机记录"></a>主机记录</h3><p>主机记录相当于域名的前缀，比如 www</p><div class="table-container"><table><thead><tr><th>记录</th><th>解释</th></tr></thead><tbody><tr><td>www</td><td>常见主机记录，将域名解析为 www.callmelp.online</td></tr><tr><td>@</td><td>直接解析主域名 callmelp.online</td></tr><tr><td>mail</td><td>将域名解析为 mail.callmelp.online，通常用于邮件服务</td></tr><tr><td>*</td><td>泛解析，匹配其他所有域名 *.callmelp.online</td></tr></tbody></table></div><p>这里可以写任何值，比如你用baidu.com这个域名，记录写baidu，你就可以用baidu.baidu.com访问某个服务器</p><h3 id="记录类型"><a href="#记录类型" class="headerlink" title="记录类型"></a>记录类型</h3><div class="table-container"><table><thead><tr><th>记录类型</th><th>使用目的</th></tr></thead><tbody><tr><td>A 记录</td><td>将域名指向一个 IP 地址（外网地址）。</td></tr><tr><td>CNAME 记录</td><td>将域名指向另一个域名，再由另一个域名提供 IP 地址（外网地址）。</td></tr><tr><td>MX 记录</td><td>设置邮箱，让邮箱能收到邮件。</td></tr><tr><td>NS 记录</td><td>将子域名交给其他 DNS 服务商解析。</td></tr><tr><td>AAAA 记录</td><td>将域名指向一个 IPv6 地址。</td></tr><tr><td>SRV 记录</td><td>用来标识某台服务器使用了某个服务，常见于微软系统的目录管理。</td></tr><tr><td>TXT 记录</td><td>对域名进行标识和说明，绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件）。</td></tr><tr><td>隐、显性 URL 记录</td><td>将一个域名指向另外一个已经存在的站点。</td></tr></tbody></table></div><p>我们使用A将域名解析到ip地址</p><hr><p>例如我们要将abc前缀的域名解析到0.0.0.0这个ip：</p><p><img src="https://www.hualigs.cn/image/60a34f6d642dd.jpg" alt=""></p><p>确认即可。</p><h2 id="SSL证书"><a href="#SSL证书" class="headerlink" title="SSL证书"></a>SSL证书</h2><p>为了用户的安全，https使用加密传输。在握手过程中，网站会向浏览器发送SSL证书，SSL证书和我们日常用的身份证类似，是一个支持HTTPS网站的身份证明，SSL证书里面包含了网站的域名，证书有效期，证书的颁发机构以及用于加密传输密码的公钥等信息，由于公钥加密的密码只能被在申请证书时生成的私钥解密，因此浏览器在生成密码之前需要先核对当前访问的域名与证书上绑定的域名是否一致，同时还要对证书的颁发机构进行验证，如果验证失败浏览器会给出证书错误的提示。在这一部分我将对SSL证书的验证过程以及个人用户在访问HTTPS网站时，对SSL证书的使用需要注意哪些安全方面的问题进行描述。</p><h3 id="腾讯云SSL证书"><a href="#腾讯云SSL证书" class="headerlink" title="腾讯云SSL证书"></a>腾讯云SSL证书</h3><p>进入<a href="https://console.cloud.tencent.com/ssl">腾讯云SSL证书管理</a></p><p><img src="https://www.hualigs.cn/image/60a350ffba75c.jpg" alt=""></p><p>点击下载即可。</p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> domain </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Octave简明教程</title>
      <link href="2021/05/15/Octave-tutorial/"/>
      <url>2021/05/15/Octave-tutorial/</url>
      
        <content type="html"><![CDATA[<p>吴恩达的机器学习课程的作业可以使用Matlab或者octave，这里记录一下octave的基本操作。<br><span id="more"></span></p><h2 id="Contents"><a href="#Contents" class="headerlink" title="Contents"></a>Contents</h2><ul><li><a href="#符号">符号</a></li><li><a href="#矩阵">矩阵</a><ul><li><a href="#矩阵初始化">矩阵初始化</a></li><li><a href="#特殊矩阵初始化">特殊矩阵初始化</a></li><li><a href="#矩阵索引">矩阵索引</a></li></ul></li><li><a href="#矩阵变化">矩阵变化</a><ul><li><a href="#重新赋值">重新赋值</a></li><li><a href="#添加到新行列">添加到新行/列</a></li><li><a href="#矩阵向量化">矩阵向量化</a></li></ul></li><li><a href="#矩阵计算">矩阵计算</a><ul><li><a href="#矩阵相加减">矩阵相加减</a></li><li><a href="#矩阵相乘除">矩阵相乘除</a></li><li><a href="#矩阵运算">矩阵运算</a></li></ul></li><li><a href="#内建函数">内建函数</a></li><li><a href="#画图">画图</a></li><li><a href="#语法">语法</a></li></ul><h3 id="符号"><a href="#符号" class="headerlink" title="符号"></a>符号</h3><div class="table-container"><table><thead><tr><th style="text-align:center">符号</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center">%</td><td style="text-align:center">注释</td></tr><tr><td style="text-align:center">~=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">;</td><td style="text-align:center">结束符</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">加</td></tr><tr><td style="text-align:center">-</td><td style="text-align:center">减</td></tr><tr><td style="text-align:center">*</td><td style="text-align:center">乘</td></tr><tr><td style="text-align:center">/</td><td style="text-align:center">除</td></tr><tr><td style="text-align:center">‘</td><td style="text-align:center">转置</td></tr></tbody></table></div><p>> , &lt; , =这些符号可以应用到矩阵中，可以将矩阵中的每一个元素和符号后的数字进行比较，最终判断成立返回1， 判断错误返回0.</p><p>示例：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="number">1</span>+<span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">2</span></span><br><span class="line">&gt;&gt; <span class="number">1</span>*<span class="number">8</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">8</span></span><br><span class="line">&gt;&gt; a = <span class="number">3</span></span><br><span class="line">a = <span class="number">3</span></span><br><span class="line">&gt;&gt; a~=<span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt; a~=<span class="number">3</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">0</span></span><br><span class="line">&gt;&gt; a = [<span class="number">11</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">1</span> <span class="number">21</span> <span class="number">3</span> ; <span class="number">1</span> <span class="number">2</span> <span class="number">32</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">11</span>    <span class="number">2</span>    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span>   <span class="number">21</span>    <span class="number">3</span></span><br><span class="line">    <span class="number">1</span>    <span class="number">2</span>   <span class="number">32</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a &gt;<span class="number">10</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">1</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">1</span></span><br><span class="line">&gt;&gt; a == <span class="number">10</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a == <span class="number">1</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">  <span class="number">0</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">  <span class="number">1</span>  <span class="number">0</span>  <span class="number">0</span></span><br><span class="line">&gt;&gt; a&#x27;</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">11</span>    <span class="number">1</span>    <span class="number">1</span></span><br><span class="line">    <span class="number">2</span>   <span class="number">21</span>    <span class="number">2</span></span><br><span class="line">    <span class="number">3</span>    <span class="number">3</span>   <span class="number">32</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><h3 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h3><h4 id="矩阵初始化"><a href="#矩阵初始化" class="headerlink" title="矩阵初始化"></a>矩阵初始化</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><p>注：<code>;</code>代表的是换行，每一行中可以拿,隔开也可以不用，直接空开就可以。</p><h4 id="特殊矩阵初始化"><a href="#特殊矩阵初始化" class="headerlink" title="特殊矩阵初始化"></a>特殊矩阵初始化</h4><p>单位阵：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">eye</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">Diagonal Matrix</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><br>全一阵：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">ones</span>(<span class="number">3</span>,<span class="number">3</span>) <span class="comment">% 前一个3为行数，后一个3为列数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><br>全零阵：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">zeros</span>(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><br>随机矩阵：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">rand</span>(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.1583</span>   <span class="number">0.6459</span>   <span class="number">0.4255</span></span><br><span class="line">   <span class="number">0.4938</span>   <span class="number">0.3079</span>   <span class="number">0.2308</span></span><br><span class="line">   <span class="number">0.1299</span>   <span class="number">0.7594</span>   <span class="number">0.4041</span></span><br></pre></td></tr></table></figure><br>魔法矩阵：每行，每列，对角的和都相等的矩阵<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">magic</span>(<span class="number">3</span>)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">8</span>   <span class="number">1</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">5</span>   <span class="number">7</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">9</span>   <span class="number">2</span></span><br></pre></td></tr></table></figure></p><h4 id="矩阵索引"><a href="#矩阵索引" class="headerlink" title="矩阵索引"></a>矩阵索引</h4><p><code>:</code>冒号表示从…到…，单独的冒号表示所有<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">︋&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>]</span><br><span class="line">&gt;&gt; a(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment">%第一行第一列</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">1</span></span><br><span class="line">&gt;&gt; a(<span class="number">2</span>, <span class="number">2</span>)   <span class="comment">%第二行第二列</span></span><br><span class="line"><span class="built_in">ans</span> = <span class="number">5</span></span><br><span class="line">&gt;&gt; a(<span class="number">1</span>:<span class="number">2</span>, <span class="number">1</span>:<span class="number">2</span>)   <span class="comment">%1到2行，1到2列</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a(:, <span class="number">1</span>:<span class="number">2</span>)     <span class="comment">%所有行，1到2列</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span></span><br></pre></td></tr></table></figure></p><h3 id="矩阵变化"><a href="#矩阵变化" class="headerlink" title="矩阵变化"></a>矩阵变化</h3><p>以下示例均使用<code>a  = [1 2 3; 4 5 6; 7 8 9]</code></p><h4 id="重新赋值"><a href="#重新赋值" class="headerlink" title="重新赋值"></a>重新赋值</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a(<span class="number">1</span>,:) = [<span class="number">7</span> <span class="number">8</span> <span class="number">9</span>] <span class="comment">%将第一行改为 7 8 9 </span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br></pre></td></tr></table></figure><h4 id="添加到新行-列"><a href="#添加到新行-列" class="headerlink" title="添加到新行/列"></a>添加到新行/列</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a = [a, [<span class="number">10</span>; <span class="number">11</span>; <span class="number">12</span>]] <span class="comment">%添加列</span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line">    <span class="number">4</span>    <span class="number">5</span>    <span class="number">6</span>   <span class="number">11</span></span><br><span class="line">    <span class="number">7</span>    <span class="number">8</span>    <span class="number">9</span>   <span class="number">12</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">&gt;&gt; a = [a ;[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]]  <span class="comment">%添加行</span></span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure><h4 id="矩阵向量化"><a href="#矩阵向量化" class="headerlink" title="矩阵向量化"></a>矩阵向量化</h4><p>按照列的顺序排布：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a  = [<span class="number">1</span> <span class="number">2</span> <span class="number">3</span>; <span class="number">4</span> <span class="number">5</span> <span class="number">6</span>; <span class="number">7</span> <span class="number">8</span> <span class="number">9</span>];</span><br><span class="line">&gt;&gt; a(:)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   <span class="number">7</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">5</span></span><br><span class="line">   <span class="number">8</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure><br>如果想按行排布，可以使用转置：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a&#x27;(:)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line">   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">4</span></span><br><span class="line">   <span class="number">5</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">7</span></span><br><span class="line">   <span class="number">8</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure></p><h3 id="矩阵计算"><a href="#矩阵计算" class="headerlink" title="矩阵计算"></a>矩阵计算</h3><h4 id="矩阵相加减"><a href="#矩阵相加减" class="headerlink" title="矩阵相加减"></a>矩阵相加减</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a+<span class="number">1</span>  </span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">    <span class="number">5</span>    <span class="number">6</span>    <span class="number">7</span></span><br><span class="line">    <span class="number">8</span>    <span class="number">9</span>   <span class="number">10</span></span><br><span class="line">&gt;&gt; a+a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">2</span>    <span class="number">4</span>    <span class="number">6</span></span><br><span class="line">    <span class="number">8</span>   <span class="number">10</span>   <span class="number">12</span></span><br><span class="line">   <span class="number">14</span>   <span class="number">16</span>   <span class="number">18</span></span><br><span class="line">&gt;&gt; a-a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line">   <span class="number">0</span>   <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a<span class="number">-1</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line">   <span class="number">3</span>   <span class="number">4</span>   <span class="number">5</span></span><br><span class="line">   <span class="number">6</span>   <span class="number">7</span>   <span class="number">8</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="矩阵相乘除"><a href="#矩阵相乘除" class="headerlink" title="矩阵相乘除"></a>矩阵相乘除</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a *a   <span class="comment">%叉乘：线性代数中的叉乘</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">30</span>    <span class="number">36</span>    <span class="number">42</span></span><br><span class="line">    <span class="number">66</span>    <span class="number">81</span>    <span class="number">96</span></span><br><span class="line">   <span class="number">102</span>   <span class="number">126</span>   <span class="number">150</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; a.*a    <span class="comment">%点乘：对应位置相乘</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">   <span class="number">16</span>   <span class="number">25</span>   <span class="number">36</span></span><br><span class="line">   <span class="number">49</span>   <span class="number">64</span>   <span class="number">81</span></span><br><span class="line">&gt;&gt; a./<span class="number">2</span>    <span class="comment">%点除：同上</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.5000</span>   <span class="number">1.0000</span>   <span class="number">1.5000</span></span><br><span class="line">   <span class="number">2.0000</span>   <span class="number">2.5000</span>   <span class="number">3.0000</span></span><br><span class="line">   <span class="number">3.5000</span>   <span class="number">4.0000</span>   <span class="number">4.5000</span></span><br></pre></td></tr></table></figure><h4 id="矩阵运算"><a href="#矩阵运算" class="headerlink" title="矩阵运算"></a>矩阵运算</h4><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a.^<span class="number">2</span>    <span class="comment">%幂运算</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">1</span>    <span class="number">4</span>    <span class="number">9</span></span><br><span class="line">   <span class="number">16</span>   <span class="number">25</span>   <span class="number">36</span></span><br><span class="line">   <span class="number">49</span>   <span class="number">64</span>   <span class="number">81</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">exp</span>(a)    <span class="comment">%指数运算：每个数都求以e为底的指数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">2.7183e+00</span>   <span class="number">7.3891e+00</span>   <span class="number">2.0086e+01</span></span><br><span class="line">   <span class="number">5.4598e+01</span>   <span class="number">1.4841e+02</span>   <span class="number">4.0343e+02</span></span><br><span class="line">   <span class="number">1.0966e+03</span>   <span class="number">2.9810e+03</span>   <span class="number">8.1031e+03</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log</span>(a)    <span class="comment">%对数运算：以e为底</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">0.6931</span>   <span class="number">1.0986</span></span><br><span class="line">   <span class="number">1.3863</span>   <span class="number">1.6094</span>   <span class="number">1.7918</span></span><br><span class="line">   <span class="number">1.9459</span>   <span class="number">2.0794</span>   <span class="number">2.1972</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log2</span>(a)    <span class="comment">%对数运算：以2为底(以什么为底就log什么)</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span>   <span class="number">1.5850</span></span><br><span class="line">   <span class="number">2.0000</span>   <span class="number">2.3219</span>   <span class="number">2.5850</span></span><br><span class="line">   <span class="number">2.8074</span>   <span class="number">3.0000</span>   <span class="number">3.1699</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">log10</span>(a)    <span class="comment">%对数运算：以10为底</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">        <span class="number">0</span>   <span class="number">0.3010</span>   <span class="number">0.4771</span></span><br><span class="line">   <span class="number">0.6021</span>   <span class="number">0.6990</span>   <span class="number">0.7782</span></span><br><span class="line">   <span class="number">0.8451</span>   <span class="number">0.9031</span>   <span class="number">0.9542</span></span><br></pre></td></tr></table></figure><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><ol><li>length()：返回的是长度，有可能是行的个数有，可能是列的个数。这取决于那个时候更大<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">length</span>(a)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">3</span></span><br><span class="line">&gt;&gt; <span class="built_in">length</span>(<span class="built_in">rand</span>(<span class="number">5</span>,<span class="number">7</span>))</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">7</span></span><br></pre></td></tr></table></figure></li><li>max():对于向量来说会返回其中最大的一个数字,对矩阵来说会返回一个向量，向量的每一列对应原来矩阵每一列的最大值<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">max</span>([ <span class="number">7</span> <span class="number">8</span> <span class="number">9</span> ])</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">9</span></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">&gt;&gt; <span class="built_in">max</span>(a, [], <span class="number">2</span>)   <span class="comment">%第三个参数表示按行找最大值（若为1则是按列找，默认为1）</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">3</span></span><br><span class="line">   <span class="number">6</span></span><br><span class="line">   <span class="number">9</span></span><br></pre></td></tr></table></figure></li><li>floor():向下取整<br>ceil():向上取整<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">floor</span>(<span class="number">10.12</span>)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">10</span></span><br><span class="line">&gt;&gt; <span class="built_in">ceil</span>(<span class="number">10.12</span>)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">11</span></span><br></pre></td></tr></table></figure></li><li>sum():按行/列相加<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">︋&gt;&gt; sum(a,<span class="number">1</span>)   <span class="comment">%第二个参数为1时，按列加（默认为1）</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">12</span>   <span class="number">15</span>   <span class="number">18</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; sum(a,<span class="number">2</span>)    <span class="comment">%第二个参数为2时，按行加</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">    <span class="number">6</span></span><br><span class="line">   <span class="number">15</span></span><br><span class="line">   <span class="number">24</span></span><br></pre></td></tr></table></figure></li><li>flipud():将矩阵上下颠倒<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; <span class="built_in">flipud</span>(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">7</span>   <span class="number">8</span>   <span class="number">9</span></span><br><span class="line">   <span class="number">4</span>   <span class="number">5</span>   <span class="number">6</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span></span><br></pre></td></tr></table></figure></li><li>rank():求矩阵的秩<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rank(a)</span><br><span class="line"><span class="built_in">ans</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li>rref():将矩阵化为行最简<figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; rref(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span>        <span class="number">0</span>  <span class="number">-1.0000</span></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span>   <span class="number">2.0000</span></span><br><span class="line">        <span class="number">0</span>        <span class="number">0</span>        <span class="number">0</span></span><br></pre></td></tr></table></figure></li><li><p>pinv():求矩阵的逆矩阵</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a=[<span class="number">3</span>,<span class="number">4</span>;<span class="number">2</span>,<span class="number">16</span>]</span><br><span class="line">a =</span><br><span class="line"></span><br><span class="line">    <span class="number">3</span>    <span class="number">4</span></span><br><span class="line">    <span class="number">2</span>   <span class="number">16</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(a)*a</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1.0000</span>  <span class="number">-0.0000</span></span><br><span class="line">        <span class="number">0</span>   <span class="number">1.0000</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; pinv(a)</span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">0.400000</span>  <span class="number">-0.100000</span></span><br><span class="line">  <span class="number">-0.050000</span>   <span class="number">0.075000</span></span><br></pre></td></tr></table></figure></li><li><p>reshape():将向量矩阵化</p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; a = <span class="built_in">ones</span>(<span class="number">10</span>,<span class="number">1</span>);       <span class="comment">%初始化一个10维向量</span></span><br><span class="line"></span><br><span class="line">&gt;&gt; <span class="built_in">reshape</span>(a, <span class="number">5</span>, <span class="number">2</span>)      <span class="comment">%第二个参数是矩阵的行数， 第三个是矩阵的列数</span></span><br><span class="line"><span class="built_in">ans</span> =</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br><span class="line">   <span class="number">1</span>   <span class="number">1</span></span><br></pre></td></tr></table></figure><h3 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h3><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt;&gt; x = <span class="number">-1</span>:<span class="number">0.1</span>:<span class="number">1</span>;</span><br><span class="line">&gt;&gt; y = x.^<span class="number">2</span>;</span><br><span class="line">&gt;&gt; <span class="built_in">plot</span>(x, y)</span><br></pre></td></tr></table></figure><p><img src="https://www.hualigs.cn/image/609f8e0201cd9.jpg" alt=""></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="built_in">hold</span> on <span class="comment">%若要保留上一次的结果就hold on</span></span><br><span class="line">y2 = -x .^ <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="built_in">plot</span>(x, y2, <span class="string">&#x27;r&#x27;</span>);</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3062143-b685e1adc68a9cc4.png?imageMogr2/auto-orient/strip|imageView2/2/w/1156/format/webp" alt=""></p><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="comment">% 加标签</span></span><br><span class="line">xlabel(<span class="string">&quot;x value&quot;</span>);</span><br><span class="line">ylabel(<span class="string">&quot;y value&quot;</span>);</span><br><span class="line"><span class="built_in">legend</span>(<span class="string">&quot;x^2&quot;</span>, <span class="string">&quot;-x^2+1&quot;</span>); <span class="comment">% 对应图中的颜色线条注释</span></span><br><span class="line">title(<span class="string">&quot;first plot&quot;</span>);</span><br><span class="line">cd Desktop; print -dpng <span class="string">&quot;firstPlot.png&quot;</span> <span class="comment">%会保存到桌面上</span></span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3062143-6504fece7838e5c5.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp" alt=""></p></li></ol><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>for循环：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:<span class="number">10</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;Hello world&quot;</span>);</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>while循环：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">while</span> a &gt; <span class="number">0</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;HI&quot;</span>);</span><br><span class="line">  a -= <span class="number">1</span>;</span><br><span class="line"><span class="keyword">end</span>;</span><br></pre></td></tr></table></figure><br>if/else:<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line">&gt; <span class="keyword">if</span> a &gt; <span class="number">1</span></span><br><span class="line">&gt;   <span class="built_in">disp</span>(<span class="string">&quot;a is bigger than 1&quot;</span>);</span><br><span class="line">&gt; <span class="keyword">else</span></span><br><span class="line">&gt;   <span class="built_in">disp</span>(<span class="string">&quot;a is smaller than 1&quot;</span>);</span><br><span class="line">&gt; endif;</span><br><span class="line"></span><br><span class="line">&gt;&gt; a is smaller than <span class="number">1</span></span><br></pre></td></tr></table></figure><br>创建函数：<br><figure class="highlight matlab"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">val</span> = <span class="title">func</span><span class="params">(x, y)</span>    %<span class="title">x</span>,<span class="title">y</span>是函数传入的参数，<span class="title">val</span>是返回值</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Octave </tag>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js web服务器搭建</title>
      <link href="2021/05/11/nodejs-webserver/"/>
      <url>2021/05/11/nodejs-webserver/</url>
      
        <content type="html"><![CDATA[<p>使用nodejs搭建文件目录结构的web服务器,以及node forever模块的使用</p><span id="more"></span><p>nodejs的安装和使用以及npm的使用方法自己查</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#目录">目录</a></li><li><a href="#web服务器搭建">web服务器搭建</a><ul><li><a href="#安装对应库">安装对应库</a></li><li><a href="#获得https的ssl证书">获得https的ssl证书</a></li><li><a href="#文件目录">文件目录</a></li><li><a href="#运行">运行</a></li><li><a href="#servejs代码web根目录">serve.js代码（web根目录）</a></li></ul></li><li><a href="#forever说明">forever说明</a><ul><li><a href="#forever安装和使用">forever安装和使用</a><ul><li><a href="#安装">安装</a></li><li><a href="#使用">使用</a></li></ul></li></ul></li></ul><h2 id="web服务器搭建"><a href="#web服务器搭建" class="headerlink" title="web服务器搭建"></a>web服务器搭建</h2><h3 id="安装对应库"><a href="#安装对应库" class="headerlink" title="安装对应库"></a>安装对应库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install express</span><br><span class="line">npm install serve-index</span><br></pre></td></tr></table></figure><h3 id="获得https的ssl证书"><a href="#获得https的ssl证书" class="headerlink" title="获得https的ssl证书"></a>获得https的ssl证书</h3><p>购买域后进行实名认证，通过后即可下载</p><h3 id="文件目录"><a href="#文件目录" class="headerlink" title="文件目录"></a>文件目录</h3><p><img src="https://www.hualigs.cn/image/609a0dde34285.jpg" width="50%"></p><p>cert:存放ssl证书<br>node_modules:nodejs的库<br>public:web页面的目录<br>server.js:web服务器代码               </p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo forever start server.js</span><br></pre></td></tr></table></figure><p>forever可以不占用终端在后台运行</p><p>停止：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo forever stop server.js</span><br></pre></td></tr></table></figure></p><p>说明：forever需要用npm下载</p><hr><p>如果想临时使用或者查看log，可以使用node运行： </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo node server.js</span><br></pre></td></tr></table></figure><h3 id="serve-js代码（web根目录）"><a href="#serve-js代码（web根目录）" class="headerlink" title="serve.js代码（web根目录）"></a>serve.js代码（web根目录）</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&#x27;use strict&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> https = <span class="built_in">require</span>(<span class="string">&#x27;https&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">&#x27;fs&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> serveIndex = <span class="built_in">require</span>(<span class="string">&#x27;serve-index&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> express = <span class="built_in">require</span>(<span class="string">&#x27;express&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> app = express();</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序不能换</span></span><br><span class="line">app.use(serveIndex(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line">app.use(express.static(<span class="string">&#x27;./public&#x27;</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> options = &#123;</span><br><span class="line">key  : fs.readFileSync(<span class="string">&#x27;./cert/callmelp.online.key&#x27;</span>),</span><br><span class="line">cert : fs.readFileSync(<span class="string">&#x27;./cert/callmelp.online.pem&#x27;</span>) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> https_server = https.createServer(options, app);</span><br><span class="line">https_server.listen(<span class="number">443</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> http_server = http.createServer(app);</span><br><span class="line">http_server.listen(<span class="number">80</span>, <span class="string">&#x27;0.0.0.0&#x27;</span>);</span><br></pre></td></tr></table></figure><h2 id="forever说明"><a href="#forever说明" class="headerlink" title="forever说明"></a>forever说明</h2><p><a href="https://github.com/foreverjs/forever">forever Github地址</a></p><p>forever可以看做是一个nodejs的守护进程，能够启动，停止，重启我们的app应用。</p><p>forever的用途就是帮我们更好的管理我们node App服务，本质上就是在forever进程之下，创建一个node app的子进程。使用类似于<code>service apache2 start</code>这样的命令即可操作node后台运行。</p><p>更好的一点就是每次更改文件，它都可以帮你自动重启服务而不需要手动重启（需要配置持续监听-w）</p><h3 id="forever安装和使用"><a href="#forever安装和使用" class="headerlink" title="forever安装和使用"></a>forever安装和使用</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install forever -g  &#x2F;&#x2F;-g 全局安装</span><br></pre></td></tr></table></figure><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol><li>启动相关<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 简单的启动</span><br><span class="line">forever start app.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 指定forever信息输出文件，当然，默认它会放到~&#x2F;.forever&#x2F;forever.log</span><br><span class="line">forever start -l forever.log app.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 3. 指定app.js中的日志信息和错误日志输出文件，</span><br><span class="line">&#x2F;&#x2F; -o 就是console.log输出的信息，-e 就是console.error输出的信息</span><br><span class="line">forever start -o out.log -e err.log app.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 4. 追加日志，forever默认是不能覆盖上次的启动日志，</span><br><span class="line">&#x2F;&#x2F; 所以如果第二次启动不加-a，则会不让运行</span><br><span class="line">forever start -l forever.log -a app.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 5. 监听当前文件夹下的所有文件改动，并重启服务</span><br><span class="line">forever start -w app.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 6. 显示所有运行的服务</span><br><span class="line">forever list</span><br></pre></td></tr></table></figure></li><li>停止<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 停止所有运行的node App</span><br><span class="line">forever stopall</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2. 停止其中一个node App</span><br><span class="line">forever stop app.js</span><br><span class="line">&#x2F;&#x2F; 当然还可以这样</span><br><span class="line">&#x2F;&#x2F; forever list 找到对应的id，然后：</span><br><span class="line">forever stop [id]</span><br></pre></td></tr></table></figure></li><li>重启<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 1. 启动所有</span><br><span class="line">forever restartall</span><br><span class="line">&#x2F;&#x2F; 2. 重启其中一个node App</span><br><span class="line">forever restart app.js</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用教程</title>
      <link href="2021/05/11/hexo-tutorial/"/>
      <url>2021/05/11/hexo-tutorial/</url>
      
        <content type="html"><![CDATA[<p>记录一下每次使用hexo写博文会使用的操作<br><span id="more"></span></p><h2 id="写新博客"><a href="#写新博客" class="headerlink" title="写新博客"></a>写新博客</h2><p>打开git bash或者cmd，进入hexo存放的工作目录<br><img src="https://www.hualigs.cn/image/609a12d37a26b.jpg" alt=""></p><p>gitbash：<br><img src="https://www.hualigs.cn/image/609a12d33a53a.jpg" alt="">  </p><p>终端执行：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &#39;xxx&#39;</span><br></pre></td></tr></table></figure><p>(xxx为文件名)<br><img src="https://www.hualigs.cn/image/609a1433e768d.jpg" alt=""><br>进如上图显示的目录，即可看到新创建的md文件。</p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>gitbash或者cmd在hexo的工作目录下输入：  </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo d -g</span><br></pre></td></tr></table></figure><p>（-g参数一定要加 先生成再上传）</p><p>我这里是配置好了github的上传操作，如果没有配置过可以看我的<a href="https://callmelp.github.io/2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/">上一篇文章</a></p>]]></content>
      
      
      <categories>
          
          <category> Tutorials </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo+github搭建个人博客总结</title>
      <link href="2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/"/>
      <url>2021/04/27/hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h1 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h1><ul><li><a href="#github生成仓库">github生成仓库</a></li><li><a href="#配置ssh略">配置ssh（略）</a></li><li><a href="#hexo安装">hexo安装</a></li><li><a href="#上传github">上传github</a></li><li><a href="#常用hexo命令">常用hexo命令</a></li><li><a href="#写博客工具">写博客工具</a></li><li><a href="#如何让博文列表不显示全部内容">如何让博文列表不显示全部内容</a></li><li><a href="#用自己的域名绑定github站点">用自己的域名绑定github站点</a></li><li><a href="#参考">参考</a></li></ul><h2 id="github生成仓库"><a href="#github生成仓库" class="headerlink" title="github生成仓库"></a>github生成仓库</h2><p>新建一个名为你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效），将来你的网站访问地址就是 <a href="http://test.github.io">http://test.github.io</a> 了，是不是很方便？</p><p>由此可见，每一个github账户最多只能创建一个这样可以直接使用域名访问的仓库。</p><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h2 id="配置ssh（略）"><a href="#配置ssh（略）" class="headerlink" title="配置ssh（略）"></a>配置ssh（略）</h2><h2 id="hexo安装"><a href="#hexo安装" class="headerlink" title="hexo安装"></a>hexo安装</h2><p>用git bash直接安装，代码：</p><pre><code>$ npm install -g hexo</code></pre><p>在电脑的某个地方新建一个名为hexo的文件夹（名字可以随便取），比如我的是F:\Workspaces\hexo，由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cd &#x2F;f&#x2F;Workspaces&#x2F;hexo&#x2F;</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure><p>hexo会自动下载一些文件到这个目录，包括node_modules。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hexo g # 生成</span><br><span class="line">$ hexo s # 启动服务</span><br></pre></td></tr></table></figure><p>执行以上命令之后，hexo就会在public文件夹生成相关html文件，这些public里的文件将来都是要提交到github去的。</p><p><code>hexo s</code>是开启本地预览服务，打开浏览器访问 <a href="http://localhost:4000">http://localhost:4000</a> 即可看到内容，很多人会碰到浏览器一直在转圈但是就是加载不出来的问题，一般情况下是因为端口占用的缘故，因为4000这个端口太常见了，解决端口冲突问题请参考这篇文章：</p><p><a href="http://blog.liuxianan.com/windows-port-bind.html">http://blog.liuxianan.com/windows-port-bind.html</a></p><h2 id="上传github"><a href="#上传github" class="headerlink" title="上传github"></a>上传github</h2><p>如果你一切都配置好了，发布上传很容易，一句hexo d就搞定，当然关键还是你要把所有东西配置好。</p><p>首先，ssh key肯定要配置好。</p><p>其次，配置_config.yml中有关deploy的部分：</p><p>正确写法：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:liuxianan&#x2F;liuxianan.github.io.git(不是https那个)</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>此时直接执行hexo d的话一般会报如下错误：</p><pre><code>Deployer not found: github 或者 Deployer not found: git</code></pre><p>原因是还需要安装一个插件：</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>其它命令不确定，部署这个命令一定要用<code>git bash</code>，否则会提示<code>Permission denied (publickey)</code>.</p><p>打开你的git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会提交。</p><h2 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h2><p>常见命令：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo new &quot;postName&quot; #新建文章</span><br><span class="line">hexo new page &quot;pageName&quot; #新建页面</span><br><span class="line">hexo generate #生成静态页面至public目录</span><br><span class="line">hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）</span><br><span class="line">hexo deploy #部署到GitHub</span><br><span class="line">hexo help  # 查看帮助</span><br><span class="line">hexo version  #查看Hexo的版本</span><br></pre></td></tr></table></figure></p><p>缩写：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo n &#x3D;&#x3D; hexo new</span><br><span class="line">hexo g &#x3D;&#x3D; hexo generate</span><br><span class="line">hexo s &#x3D;&#x3D; hexo server</span><br><span class="line">hexo d &#x3D;&#x3D; hexo deploy</span><br></pre></td></tr></table></figure></p><h2 id="写博客"><a href="#写博客" class="headerlink" title="写博客"></a>写博客</h2><p>定位到我们的hexo根目录，执行命令：</p><pre><code>hexo new &#39;my-first-blog&#39;</code></pre><p>hexo会帮我们在_posts下生成相关md文件，我们只需要打开这个文件就可以开始写博客了（想删除博文是只用删掉对应生成的md文件就行了）。</p><h2 id="写博客工具"><a href="#写博客工具" class="headerlink" title="写博客工具"></a>写博客工具</h2><p>具体用什么还是看个人喜好，我用vscode非常方便。只需要下载两个插件：</p><pre><code>Markdown All in OneMarkdown Preview Github Styling</code></pre><p>在vscode里写完可以直接看到md生成的效果。</p><h2 id="如何让博文列表不显示全部内容"><a href="#如何让博文列表不显示全部内容" class="headerlink" title="如何让博文列表不显示全部内容"></a>如何让博文列表不显示全部内容</h2><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？</p><p>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p><pre><code>使用github pages服务搭建博客的好处有：1. 全是静态文件，访问速度快；2. 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；3. 可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；&lt;!--more--&gt;4. 数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；5. 博客内容可以轻松打包、转移、发布到其它平台；6. 等等；</code></pre><h2 id="用自己的域名绑定github站点"><a href="#用自己的域名绑定github站点" class="headerlink" title="用自己的域名绑定github站点"></a>用自己的域名绑定github站点</h2><p>进入github项目目录，点击<code>Add file</code>-&gt;<code>creat new file</code></p><p><img src="https://www.hualigs.cn/image/60a776cc2d319.jpg" alt=""></p><p>文件名写CNAME,文件里写上你的域名（不加前缀www）</p><p><img src="https://www.hualigs.cn/image/60a7773274579.jpg" alt=""></p><p>进入你的域名解析页面，添加CNAME记录</p><p><img src="https://www.hualigs.cn/image/60a778873c35d.jpg" alt=""></p><p>OK!现在就可以用你自己的域名访问你的博客啦</p><p><img src="https://www.hualigs.cn/image/60a778ee3739a.jpg" alt=""></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/liuxianan/p/build-blog-website-by-hexo-github.html">使用hexo+github搭建免费个人博客详细教程</a></p><p><a href="https://hexo.io/zh-cn/docs/">hexo官方中文文档</a></p>]]></content>
      
      
      <categories>
          
          <category> Log </category>
          
      </categories>
      
      
        <tags>
            
            <tag> github </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2021/04/27/hello-world/"/>
      <url>2021/04/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
